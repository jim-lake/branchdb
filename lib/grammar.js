// Generated by PEG.js v0.11.0-dev, https://pegjs.org/

"use strict";

function peg$subclass(child, parent) {
  function C() { this.constructor = child; }
  C.prototype = parent.prototype;
  child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  // istanbul ignore next
  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },

    class: function(expectation) {
      var escapedParts = expectation.parts.map(function(part) {
        return Array.isArray(part)
          ? classEscape(part[0]) + "-" + classEscape(part[1])
          : classEscape(part);
      });

      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },

    any: function() {
      return "any character";
    },

    end: function() {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    },

    not: function(expectation) {
      return "not " + describeExpectation(expectation.expected);
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/"/g,  "\\\"")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/\]/g, "\\]")
      .replace(/\^/g, "\\^")
      .replace(/-/g,  "\\-")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = expected.map(describeExpectation);
    var i, j;

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$DefaultTracer() {
  this.indentLevel = 0;
}

peg$DefaultTracer.prototype.trace = function(event) {
  var that = this;

  function log(event) {
    function repeat(string, n) {
       var result = "", i;

       for (i = 0; i < n; i++) {
         result += string;
       }

       return result;
    }

    function pad(string, length) {
      return string + repeat(" ", length - string.length);
    }

    if (typeof console === "object") {
      console.log(
        event.location.start.line + ":" + event.location.start.column + "-"
          + event.location.end.line + ":" + event.location.end.column + " "
          + pad(event.type, 10) + " "
          + repeat("  ", that.indentLevel) + event.rule
      );
    }
  }

  switch (event.type) {
    case "rule.enter":
      log(event);
      this.indentLevel++;
      break;

    case "rule.match":
      this.indentLevel--;
      log(event);
      break;

    case "rule.fail":
      this.indentLevel--;
      log(event);
      break;

    // istanbul ignore next
    default:
      throw new Error("Invalid event type: " + event.type + ".");
  }
};

function peg$parse(input, options) {
  options = options !== undefined ? options : {};

  var peg$FAILED = {};

  var peg$startRuleFunctions = { start: peg$parsestart, start_streaming: peg$parsestart_streaming };
  var peg$startRuleFunction = peg$parsestart;

  var peg$c0 = "''";
  var peg$c1 = "e";
  var peg$c2 = "0x";
  var peg$c3 = "$";
  var peg$c4 = ":";
  var peg$c5 = "not ";
  var peg$c6 = "null";
  var peg$c7 = "statement";
  var peg$c8 = "n";
  var peg$c9 = "var";
  var peg$c10 = "char";
  var peg$c11 = "tiny";
  var peg$c12 = "medium";
  var peg$c13 = "long";
  var peg$c14 = "text";
  var peg$c15 = "clob";
  var peg$c16 = "float";
  var peg$c17 = "real";
  var peg$c18 = "double";
  var peg$c19 = "precision";
  var peg$c20 = "numeric";
  var peg$c21 = "decimal";
  var peg$c22 = "boolean";
  var peg$c23 = "date";
  var peg$c24 = "time";
  var peg$c25 = "stamp";
  var peg$c26 = "string";
  var peg$c27 = "int";
  var peg$c28 = "2";
  var peg$c29 = "4";
  var peg$c30 = "8";
  var peg$c31 = "eger";
  var peg$c32 = "big";
  var peg$c33 = "small";
  var peg$c34 = "floating";
  var peg$c35 = "point";
  var peg$c36 = "blob";
  var peg$c37 = "\\u";
  var peg$c38 = "\"";
  var peg$c39 = "\"\"";
  var peg$c40 = "'";
  var peg$c41 = "`";
var peg$c42 = "``";
  var peg$c43 = "[";
  var peg$c44 = "]";
  var peg$c45 = "(";
  var peg$c46 = ")";
  var peg$c47 = ",";
  var peg$c48 = ".";
  var peg$c49 = "*";
  var peg$c50 = "?";
  var peg$c51 = "~";
  var peg$c52 = "+";
  var peg$c53 = "-";
  var peg$c54 = "=";
  var peg$c55 = "&";
  var peg$c56 = "|";
  var peg$c57 = "%";
  var peg$c58 = "<";
  var peg$c59 = ">";
  var peg$c60 = "!";
  var peg$c61 = ";";
  var peg$c62 = "/";
  var peg$c63 = "\\";
  var peg$c64 = "abort";
  var peg$c65 = "action";
  var peg$c66 = "add";
  var peg$c67 = "after";
  var peg$c68 = "all";
  var peg$c69 = "alter";
  var peg$c70 = "analyze";
  var peg$c71 = "and";
  var peg$c72 = "as";
  var peg$c73 = "asc";
  var peg$c74 = "attach";
  var peg$c75 = "autoincrement";
  var peg$c76 = "before";
  var peg$c77 = "begin";
  var peg$c78 = "between";
  var peg$c79 = "by";
  var peg$c80 = "cascade";
  var peg$c81 = "case";
  var peg$c82 = "cast";
  var peg$c83 = "check";
  var peg$c84 = "collate";
  var peg$c85 = "column";
  var peg$c86 = "commit";
  var peg$c87 = "conflict";
  var peg$c88 = "constraint";
  var peg$c89 = "create";
  var peg$c90 = "cross";
  var peg$c91 = "current_date";
  var peg$c92 = "current_time";
  var peg$c93 = "current_timestamp";
  var peg$c94 = "database";
  var peg$c95 = "default";
  var peg$c96 = "deferrable";
  var peg$c97 = "deferred";
  var peg$c98 = "delete";
  var peg$c99 = "desc";
  var peg$c100 = "detach";
  var peg$c101 = "distinct";
  var peg$c102 = "drop";
  var peg$c103 = "each";
  var peg$c104 = "else";
  var peg$c105 = "end";
  var peg$c106 = "escape";
  var peg$c107 = "except";
  var peg$c108 = "exclusive";
  var peg$c109 = "exists";
  var peg$c110 = "explain";
  var peg$c111 = "fail";
  var peg$c112 = "for";
  var peg$c113 = "foreign";
  var peg$c114 = "from";
  var peg$c115 = "full";
  var peg$c116 = "glob";
  var peg$c117 = "group";
  var peg$c118 = "having";
  var peg$c119 = "if";
  var peg$c120 = "ignore";
  var peg$c121 = "immediate";
  var peg$c122 = "in";
  var peg$c123 = "index";
  var peg$c124 = "indexed";
  var peg$c125 = "initially";
  var peg$c126 = "inner";
  var peg$c127 = "insert";
  var peg$c128 = "instead";
  var peg$c129 = "intersect";
  var peg$c130 = "into";
  var peg$c131 = "is";
  var peg$c132 = "isnull";
  var peg$c133 = "join";
  var peg$c134 = "key";
  var peg$c135 = "left";
  var peg$c136 = "like";
  var peg$c137 = "limit";
  var peg$c138 = "match";
  var peg$c139 = "natural";
  var peg$c140 = "no";
  var peg$c141 = "not";
  var peg$c142 = "notnull";
  var peg$c143 = "of";
  var peg$c144 = "offset";
  var peg$c145 = "on";
  var peg$c146 = "or";
  var peg$c147 = "order";
  var peg$c148 = "outer";
  var peg$c149 = "plan";
  var peg$c150 = "pragma";
  var peg$c151 = "primary";
  var peg$c152 = "query";
  var peg$c153 = "raise";
  var peg$c154 = "recursive";
  var peg$c155 = "references";
  var peg$c156 = "regexp";
  var peg$c157 = "reindex";
  var peg$c158 = "release";
  var peg$c159 = "rename";
  var peg$c160 = "replace";
  var peg$c161 = "restrict";
  var peg$c162 = "right";
  var peg$c163 = "rollback";
  var peg$c164 = "row";
  var peg$c165 = "rowid";
  var peg$c166 = "savepoint";
  var peg$c167 = "schema";
  var peg$c168 = "select";
  var peg$c169 = "set";
  var peg$c170 = "show";
  var peg$c171 = "table";
  var peg$c172 = "temp";
  var peg$c173 = "temporary";
  var peg$c174 = "then";
  var peg$c175 = "to";
  var peg$c176 = "transaction";
  var peg$c177 = "trigger";
  var peg$c178 = "union";
  var peg$c179 = "unique";
  var peg$c180 = "update";
  var peg$c181 = "using";
  var peg$c182 = "vacuum";
  var peg$c183 = "values";
  var peg$c184 = "view";
  var peg$c185 = "virtual";
  var peg$c186 = "when";
  var peg$c187 = "where";
  var peg$c188 = "with";
  var peg$c189 = "without";
  var peg$c190 = "--";
  var peg$c191 = "/*";
  var peg$c192 = "*/";
  var peg$c193 = "__TODO__";

  var peg$r0 = /^[\t ]/;
  var peg$r1 = /^[^']/;
  var peg$r2 = /^[x]/i;
  var peg$r3 = /^[+\-]/;
  var peg$r4 = /^[0-9a-f]/i;
  var peg$r5 = /^[0-9]/;
  var peg$r6 = /^[1-9]/;
  var peg$r7 = /^[:@]/;
  var peg$r8 = /^[a-z0-9$_]/i;
  var peg$r9 = /^[a-f0-9]/i;
  var peg$r10 = /^[ \t]/;
  var peg$r11 = /^[^"]/;
  var peg$r12 = /^[^`]/;
var peg$r13 = /^[\n\v\f\r]/;
var peg$r14 = /^[\n\v\f\r\t ]/;

var peg$e0 = peg$otherExpectation("Statement");
var peg$e1 = peg$otherExpectation("Semicolon");
var peg$e2 = peg$otherExpectation("Whitespace");

var peg$f0 = function(s) {
    return s;
  };
var peg$f1 = function(f, b) {
    return {
      'type': 'statement',
      'variant': 'list',
      'statement': flattenAll([ f, b ])
    };
  };
var peg$f2 = function(s) { return s; };
var peg$f3 = function(t, a) {
    return Object.assign(t, a);
  };
var peg$f4 = function(n) {
    return {
      'type': 'datatype',
      'variant': n[0],
      'affinity': n[1]
    };
  };
var peg$f5 = function(t, r) {
    const variant = foldStringKey([ t, r ]);
    let affinity = 'numeric';
    if (/int/i.test(variant)) {
      affinity = 'integer';
    } else if (/char|clob|text/i.test(variant)) {
      affinity = 'text';
    } else if (/blob/i.test(variant)) {
      affinity = 'blob';
    } else if (/real|floa|doub/i.test(variant)) {
      affinity = 'real';
    }
    return {
      'type': 'datatype',
      'variant': variant,
      'affinity': affinity
    };
  };
var peg$f6 = function(w) {
    return w;
  };
var peg$f7 = function(a1, a2) {
    return {
      'args': {
        'type': 'expression',
        'variant': 'list',
        'expression': flattenAll([ a1, a2 ])
      }
    };
  };
var peg$f8 = function(n) { return n; };
var peg$f9 = function(n) {
    return {
      'type': 'literal',
      'variant': 'null',
      'value': keyNode(n)
    };
  };
var peg$f10 = function(d) {
    return {
      'type': 'literal',
      'variant': 'date',
      'value': keyNode(d)
    };
  };
var peg$f11 = function(n, s) {
    return {
      'type': 'literal',
      'variant': 'text',
      'value': s
    };
  };
var peg$f12 = function(s) {
    /**
     * @note Unescaped the pairs of literal single quotation marks
     */
    /**
     * @note Not sure if the BLOB type should be un-escaped
     */
    return unescape(s, "'");
  };
var peg$f13 = function(b) {
    return {
      'type': 'literal',
      'variant': 'blob',
      'value': b
    };
  };
var peg$f14 = function(n) {
    return {
      'type': 'literal',
      'variant': 'text',
      'value': n
    };
  };
var peg$f15 = function(s, n) {
    if (isOkay(s)) {
      n['value'] = foldStringWord([ s, n['value'] ]);
    }
    return n;
  };
var peg$f16 = function(d, e) {
    return {
      'type': 'literal',
      'variant': 'decimal',
      'value': foldStringWord([ d, e ])
    };
  };
var peg$f17 = function(f, b) { return foldStringWord([ f, b ]); };
var peg$f18 = function(t, d) { return foldStringWord([ t, d ]); };
var peg$f19 = function(e, s, d) { return foldStringWord([ e, s, d ]); };
var peg$f20 = function(f, b) {
    return {
      'type': 'literal',
      'variant': 'hexidecimal',
      'value': foldStringWord([ f, b ])
    };
  };
var peg$f21 = function(b) {
    return Object.assign({
      'type': 'variable'
    }, b);
  };
var peg$f22 = function(q, id) {
    return {
      'format': 'numbered',
      'name': foldStringWord([ q, id ])
    };
  };
var peg$f23 = function(f, r) {
    return foldStringWord([ f, r ]);
  };
var peg$f24 = function(s, name) {
    return {
      'format': 'named',
      'name': foldStringWord([ s, name ])
    };
  };
var peg$f25 = function(d, name, s) {
    return Object.assign({
      'format': 'tcl',
      'name': foldStringWord([ d, name ])
    }, s);
  };
var peg$f26 = function(sfx) {
    return {
      'suffix': sfx
    };
  };
var peg$f27 = function(n, e) {
    if (isOkay(n)) {
      return {
        'type': 'expression',
        'format': 'unary',
        'variant': 'exists',
        'expression': e,
        'operator': keyNode(n)
      };
    }
    return e;
  };
var peg$f28 = function(n, x) { return foldStringKey([ n, x ]); };
var peg$f29 = function(s, a) {
    return Object.assign({
      'type': 'expression',
      'format': 'unary',
      'variant': keyNode(s),
      'expression': a
    }, a);
  };
var peg$f30 = function(a) {
    return Object.assign({
      'type': 'error'
    }, a);
  };
var peg$f31 = function(f) {
    return {
      'action': keyNode(f)
    };
  };
var peg$f32 = function(f, m) {
    return {
      'action': keyNode(f),
      'message': m
    };
  };
var peg$f33 = function(n) {
    return n;
  };
var peg$f34 = function(e, c) {
    return Object.assign(c, {
      'expression': e
    });
  };
var peg$f35 = function(op, e) {
    return {
      'type': 'expression',
      'format': 'unary',
      'variant': 'operation',
      'expression': e,
      'operator': keyNode(op)
    };
  };
var peg$f36 = function(c) {
    return Object.assign({
      'type': 'expression',
      'format': 'unary',
      'variant': 'operation',
      'operator': 'collate'
    }, c);
  };
var peg$f37 = function(f, rest) { return composeBinary(f, rest); };
var peg$f38 = function(i) {
    return [null, i, null, {
      'type': 'literal',
      'variant': 'null',
      'value': 'null'
    }];
  };
var peg$f39 = function() { return 'not'; };
var peg$f40 = function() { return 'is'; };
var peg$f41 = function(s, e, a) {
    return {
      'type': 'expression',
      'format': 'unary',
      'variant': keyNode(s),
      'expression': e,
      'as': a
    };
  };
var peg$f42 = function(d) { return d; };
var peg$f43 = function(t, e, w, s) {
    return Object.assign({
      'type': 'expression',
      'variant': keyNode(t),
      'expression': flattenAll([ w, s ])
    }, e);
  };
var peg$f44 = function(e) {
    return {
      'discriminant': e
    };
  };
var peg$f45 = function(s, w, t) {
    return {
      'type': 'condition',
      'variant': keyNode(s),
      'condition': w,
      'consequent': t
    };
  };
var peg$f46 = function(s, e) {
    return {
      'type': 'condition',
      'variant': keyNode(s),
      'consequent': e
    };
  };
var peg$f47 = function(v, p) {
    return Object.assign(p, {
      'left': v
    });
  };
var peg$f48 = function(n, m, e, x) {
    return Object.assign({
      'type': 'expression',
      'format': 'binary',
      'variant': 'operation',
      'operation': foldStringKey([ n, m ]),
      'right': e
    }, x);
  };
var peg$f49 = function(s, e) {
    return {
      'escape': e
    };
  };
var peg$f50 = function(n, b, tail) {
    return {
      'type': 'expression',
      'format': 'binary',
      'variant': 'operation',
      'operation': foldStringKey([ n, b ]),
      'right': tail
    };
  };
var peg$f51 = function(f, rest) { return composeBinary(f, [ rest ]); };
var peg$f52 = function(n) { return keyNode(n); };
var peg$f53 = function(n, i, e) {
    return {
      'type': 'expression',
      'format': 'binary',
      'variant': 'operation',
      'operation': foldStringKey([ n, i ]),
      'right': e
    };
  };
var peg$f54 = function(e) { return e; };
var peg$f55 = function(l) {
    return {
      'type': 'expression',
      'variant': 'list',
      'expression': isOkay(l) ? l : []
    };
  };
var peg$f56 = function(f, rest) {
    return flattenAll([ f, rest ]);
  };
var peg$f57 = function(n, a) {
    return Object.assign({
      'type': 'function',
      'name': n
    }, a);
  };
var peg$f58 = function(s) {
    return {
      'args': {
        'type': 'identifier',
        'variant': 'star',
        'name': s
      }
    };
  };
var peg$f59 = function(d, e) {
    return !isOkay(d) || e['expression'].length > 0;
  };
var peg$f60 = function(d, e) {
    return {
      'args': Object.assign(e, d)
    };
  };
var peg$f61 = function(s) {
    return {
      'filter': keyNode(s)
    };
  };
var peg$f62 = function(m) { return m; };
var peg$f63 = function(m, s) {
    return Object.assign(s, m);
  };
var peg$f64 = function(e, q) {
    return {
      'explain': isOkay(e)
    };
  };
var peg$f65 = function(q, p) { return foldStringKey([ q, p ]); };
var peg$f66 = function(s, t) {
    return {
      'type': 'statement',
      'variant': 'transaction',
      'action': 'commit'
    };
  };
var peg$f67 = function(s, m, t, n) {
    return Object.assign({
      'type': 'statement',
      'variant': 'transaction',
      'action': 'begin'
    }, m, n);
  };
var peg$f68 = function(t) { return t; };
var peg$f69 = function(m) {
    return {
      'defer': keyNode(m)
    };
  };
var peg$f70 = function(s, n) {
    return Object.assign({
      'type': 'statement',
      'variant': 'transaction',
      'action': 'rollback'
    }, n);
  };
var peg$f71 = function(n) {
    return {
      'savepoint': n
    }
  };
var peg$f72 = function(s) { return keyNode(s); };
var peg$f73 = function(s, n) {
    return {
      'type': 'statement',
      'variant': s,
      'target': n
    };
  };
var peg$f74 = function(s, a, n) {
    return {
      'type': 'statement',
      'variant': keyNode(s),
      'target': n
    };
  };
var peg$f75 = function(s, n, e) {
    return Object.assign({
      'type': 'statement',
      'variant': keyNode(s),
      'target': n
    }, e);
  };
var peg$f76 = function(a, t) { return foldStringKey([ a, t ]); };
var peg$f77 = function(s, n) {
    return {
      'action': keyNode(s),
      'name': n
    };
  };
var peg$f78 = function(s, d) {
    return {
      'action': keyNode(s),
      'definition': d
    };
  };
var peg$f79 = function(w, s) { return Object.assign(s, w); };
var peg$f80 = function(s, v, t) {
    var recursive = {
      'variant': isOkay(v) ? 'recursive' : 'common'
    };
    if (isArrayOkay(t)) {
      // Add 'recursive' property into each table expression
      t = t.map(function (elem) {
        return Object.assign(elem, recursive);
      });
    }
    return {
      'with': t
    };
  };
var peg$f81 = function(f, r) { return flattenAll([ f, r ]); };
var peg$f82 = function(t, s) {
    return Object.assign({
      'type': 'expression',
      'format': 'table',
      'variant': 'common',
      'target': t
    }, s);
  };
var peg$f83 = function(s) {
    return {
      'expression': s
    };
  };
var peg$f84 = function(w, s) {
    return Object.assign(s, w);
  };
var peg$f85 = function(a, b, e, n) {
    return {
      'type': 'statement',
      'variant': keyNode(a),
      'target': n,
      'attach': e
    };
  };
var peg$f86 = function(d, b, n) {
    return {
      'type': 'statement',
      'variant': keyNode(d),
      'target': n
    };
  };
var peg$f87 = function(v, t) {
    return Object.assign({
      'type': 'statement',
      'variant': 'vacuum'
    }, t);
  };
var peg$f88 = function(t) {
    return {
      'target': t
    };
  };
var peg$f89 = function(s, a) {
    return Object.assign({
      'type': 'statement',
      'variant': keyNode(s)
    }, a);
  };
var peg$f90 = function(n) {
    return {
      'target': n['name']
    };
  };
var peg$f91 = function(a) {
    return {
      'target': a['name']
    };
  };
var peg$f92 = function(s, n, v) {
    return {
      'type': 'statement',
      'variant': keyNode(s),
      'target': n,
      'args': {
        'type': 'expression',
        'variant': 'list',
        'expression': v
      }
    };
  };
var peg$f93 = function(v) { return v; };
var peg$f94 = function(v) { return /^(yes|no|on|off|false|true|0|1)$/i.test(v) };
var peg$f95 = function(v) {
    return {
      'type': 'literal',
      'variant': 'boolean',
      'normalized': (/^(yes|on|true|1)$/i.test(v) ? '1' : '0'),
      'value': v
    };
  };
var peg$f96 = function(n) {
    return keyNode(n);
  };
var peg$f97 = function(n) {
    return {
      'type': 'identifier',
      'variant': 'name',
      'name': n
    };
  };
var peg$f98 = function(s, o, l) {
    return Object.assign(s, o, l);
  };
var peg$f99 = function(d) {
    return {
      'order': d['result']
    };
  };
var peg$f100 = function(s, e, d) {
    return {
      'limit': Object.assign({
        'type': 'expression',
        'variant': 'limit',
        'start': e
      }, d)
    };
  };
var peg$f101 = function(o, e) {
    return {
      'offset': e
    };
  };
var peg$f102 = function(s, u) {
    if (isArrayOkay(u)) {
      return {
        'type': 'statement',
        'variant': 'compound',
        'statement': s,
        'compound': u
      };
    } else {
      return s;
    }
  };
var peg$f103 = function(c, s) {
    return {
      'type': 'compound',
      'variant': c,
      'statement': s
    };
  };
var peg$f104 = function(s, f, w, g) {
    return Object.assign({
      'type': 'statement',
      'variant': 'select',
    }, s, f, w, g);
  };
var peg$f105 = function(d, t) {
    return Object.assign({
      'result': t
    }, d);
  };
var peg$f106 = function(s) {
    return {
      'distinct': true
    };
  };
var peg$f107 = function(s) {
    return {};
  };
var peg$f108 = function(f, s) {
    return {
      'from': s
    };
  };
var peg$f109 = function(f, e) {
    return {
      'where': makeArray(e)
    };
  };
var peg$f110 = function(f, e, h) {
    return Object.assign({
      'group': e
    }, h);
  };
var peg$f111 = function(f, e) {
    return {
      'having': e
    };
  };
var peg$f112 = function(q, s) {
    return {
      'type': 'identifier',
      'variant': 'star',
      'name': foldStringWord([ q, s ])
    };
  };
var peg$f113 = function(n, s) { return foldStringWord([ n, s ]); };
var peg$f114 = function(e, a) {
    return Object.assign(e, a);
  };
var peg$f115 = function(f, t) {
    if (isArrayOkay(t)) {
      return {
        'type': 'map',
        'variant': 'join',
        'source': f,
        'map': t
      };
    }
    return f;
  };
var peg$f116 = function(cl, c) {
    return Object.assign(cl, c);
  };
var peg$f117 = function(n) {
    return {
      'type': 'join',
      'variant': 'cross join',
      'source': n
    };
  };
var peg$f118 = function(o, n) {
    return {
      'type': 'join',
      'variant': keyNode(o),
      'source': n
    };
  };
var peg$f119 = function(n, l, a) {
    return Object.assign({
      'type': 'function',
      'variant': 'table',
      'name': n,
      'args': l
    }, a);
  };
var peg$f120 = function(d, i) {
    return Object.assign(d, i);
  };
var peg$f121 = function(n, a) {
    return Object.assign(n, a);
  };
var peg$f122 = function(s, n) {
    return {
      'index': n
    };
  };
var peg$f123 = function(n, i) {
    // TODO: Not sure what should happen here
    return {
      'index': foldStringKey([ n, i ])
    };
  };
var peg$f124 = function(l, a) { return Object.assign(l, a); };
var peg$f125 = function(s, a) {
    return Object.assign(s, a);
  };
var peg$f126 = function(a, n) {
    return {
      'alias': n
    };
  };
var peg$f127 = function(n, t, j) { return foldStringKey([ n, t, j ]); };
var peg$f128 = function(t, o) { return foldStringKey([ t, o ]); };
var peg$f129 = function(t) { return keyNode(t); };
var peg$f130 = function(c) {
    return {
      'constraint': Object.assign({
        'type': 'constraint',
        'variant': 'join'
      }, c)
    }
  };
var peg$f131 = function(s, e) {
    return {
      'format': keyNode(s),
      'on': e
    };
  };
var peg$f132 = function(s, e) {
    return {
      'format': keyNode(s),
      'using': e
    };
  };
var peg$f133 = function(s, l) {
    return {
      'type': 'statement',
      'variant': 'select',
      'result': l
    };
  };
var peg$f134 = function(f, b) {
    return {
      'result': flattenAll([ f, b ])
    };
  };
var peg$f135 = function(i) { return i; };
var peg$f136 = function(e, d) {
    // Only convert this into an ordering expression if it contains
    // more than just the expression.
    if (isOkay(d)) {
      return Object.assign({
        'type': 'expression',
        'variant': 'order',
        'expression': e
      }, d);
    }
    return e;
  };
var peg$f137 = function(k, t) {
    return Object.assign({
      'type': 'statement',
      'variant': 'insert'
    }, k, t);
  };
var peg$f138 = function(a, m) {
    return Object.assign({
      'action': keyNode(a)
    }, m);
  };
var peg$f139 = function(a) {
    return {
      'action': keyNode(a)
    };
  };
var peg$f140 = function(s, m) {
    return {
      'or': keyNode(m)
    };
  };
var peg$f141 = function(i, r) {
    return Object.assign({
      'into': i
    }, r);
  };
var peg$f142 = function(s, t) {
    return t;
  };
var peg$f143 = function(r) {
    return {
      'result': r
    };
  };
var peg$f144 = function(f, b) {
    return {
      'columns': flattenAll([ f, b ])
    };
  };
var peg$f145 = function(c) { return c; };
var peg$f146 = function(n) {
    return {
      'type': 'identifier',
      'variant': 'column',
      'name': n
    };
  };
var peg$f147 = function(s, r) { return r; };
var peg$f148 = function(f, b) { return flattenAll([ f, b ]); };
var peg$f149 = function(e) {
    return e;
  };
var peg$f150 = function(d, v) {
    return {
      'type': 'values',
      'variant': 'default'
      // TODO: Not sure what should go here
      // , 'values': null
    };
  };
var peg$f151 = function(s, a) { return foldStringKey([ s, a ]); };
var peg$f152 = function(a) { return a; };
var peg$f153 = function(s, f, t, u, w, o, l) {
    return Object.assign({
      'type': 'statement',
      'variant': s,
      'into': t
    }, f, u, w, o, l);
  };
var peg$f154 = function(t) {
    return {
      'or': keyNode(t)
    };
  };
var peg$f155 = function(c) {
    return {
      'set': c
    };
  };
var peg$f156 = function(f, e) {
    return {
      'type': 'assignment',
      'target': f,
      'value': e
    };
  };
var peg$f157 = function(s, t, w, o, l) {
    return Object.assign({
      'type': 'statement',
      'variant': s,
      'from': t
    }, w, o, l);
  };
var peg$f158 = function(s, id) {
  return Object.assign({
    'type': 'statement',
    'variant': 'create',
    'format': 'schema',
    'target': id,
  });
 };
var peg$f159 = function(s, id) {
  return Object.assign({
    'type': 'statement',
    'variant': 'create',
    'format': 'database',
    'target': id,
  });
 };
var peg$f160 = function(s, ne, id, r) {
    return Object.assign({
      'type': 'statement',
      'target': id
    }, s, r, ne);
  };
var peg$f161 = function(s, tmp, t) {
    return Object.assign({
      'variant': s,
      'format': keyNode(t)
    }, tmp);
  };
var peg$f162 = function(t) {
    return {
      'temporary': isOkay(t)
    };
  };
var peg$f163 = function(i, n, e) {
    return {
      'condition': makeArray({
        'type': 'condition',
        'variant': keyNode(i),
        'condition': {
          'type': 'expression',
          'variant': keyNode(e),
          'operator': foldStringKey([ n, e ])
        }
      })
    };
  };
var peg$f164 = function(s, t, r) {
    return Object.assign({
      'definition': flattenAll([ s, t ])
    }, r);
  };
var peg$f165 = function(r, w) {
    return {
      'optimization': [{
        'type': 'optimization',
        'value': foldStringKey([ r, w ])
      }]
    };
  };
var peg$f166 = function(f) { return f; };
var peg$f167 = function(n, t, c) {
    return Object.assign({
      'type': 'definition',
      'variant': 'column',
      'name': n,
      'definition': (isOkay(c) ? c : []),
    }, t);
  };
var peg$f168 = function(t) {
    return {
      'datatype': t
    };
  };
var peg$f169 = function(n, c, ln) {
    return Object.assign(c, n);
  };
var peg$f170 = function(cl) {
    return cl[cl.length - 1];
  };
var peg$f171 = function(n) {
    return {
      'name': n
    };
  };
var peg$f172 = function(f) {
    return Object.assign({
      'variant': 'foreign key'
    }, f);
  };
var peg$f173 = function(p, d, c, a) {
    return Object.assign(p, c, d, a);
  };
var peg$f174 = function(s, k) {
    return {
      'type': 'constraint',
      'variant': foldStringKey([ s, k ])
    };
  };
var peg$f175 = function(a) {
    return {
      'autoIncrement': true
    };
  };
var peg$f176 = function(s, c) {
    return Object.assign({
      'type': 'constraint',
      'variant': s
    }, c);
  };
var peg$f177 = function(n, l) { return foldStringKey([ n, l ]); };
var peg$f178 = function(s, v) {
    return {
      'type': 'constraint',
      'variant': keyNode(s),
      'value': v
    };
  };
var peg$f179 = function(c) {
    return {
      'type': 'constraint',
      'variant': 'collate',
      'collate': c
    };
  };
var peg$f180 = function(n, c, nl) {
    return Object.assign({
      'type': 'definition',
      'variant': 'constraint'
    }, c, n);
  };
var peg$f181 = function(c) {
    return {
      'definition': makeArray(c)
    };
  };
var peg$f182 = function(k, c, t) {
    return {
      'definition': makeArray(Object.assign(k, t, c[1])),
      'columns': c[0]
    };
  };
var peg$f183 = function(s) {
    return {
      'type': 'constraint',
      'variant': keyNode(s)
    };
  };
var peg$f184 = function(p, k) { return foldStringKey([ p, k ]); };
var peg$f185 = function(u) { return keyNode(u); };
var peg$f186 = function(f, b) {
    return [f].concat(b);
  };
var peg$f187 = function(c) {
    return c.map(([ res ]) => res);
  };
var peg$f188 = function(c) {
    const auto = c.find(([ res, a ]) => isOkay(a));
    return [
      c.map(([ res, a ]) => res),
      auto ? auto[1] : null
    ];
  };
var peg$f189 = function(e, d, a) {
    // Only convert this into an ordering expression if it contains
    // more than just the expression.
    let res = e;
    if (isOkay(d)) {
      res = Object.assign({
        'type': 'expression',
        'variant': 'order',
        'expression': e
      }, d);
    }
    return [ res, a ];
  };
var peg$f190 = function(c) {
    return {
      'collate': makeArray(c)
    };
  };
var peg$f191 = function(t) {
    return {
      'direction': keyNode(t),
    };
  };
var peg$f192 = function(s, t) {
    return {
      'conflict': keyNode(t)
    };
  };
var peg$f193 = function(o, c) { return foldStringKey([ o, c ]); };
var peg$f194 = function(k, c) {
    return {
      'type': 'constraint',
      'variant': keyNode(k),
      'expression': c
    };
  };
var peg$f195 = function(k, l, c) {
    return Object.assign({
      'definition': makeArray(Object.assign(k, c))
    }, l);
  };
var peg$f196 = function(f, k) {
    return {
      'type': 'constraint',
      'variant': foldStringKey([ f, k ])
    };
  };
var peg$f197 = function(r, a, d) {
    return Object.assign({
      'type': 'constraint'
    }, r, a, d);
  };
var peg$f198 = function(s, t) {
    return {
      'references': t
    };
  };
var peg$f199 = function(f, b) {
    return {
      'action': flattenAll([ f, b ])
    };
  };
var peg$f200 = function(m, a, n) {
    return {
      'type': 'action',
      'variant': keyNode(m),
      'action': keyNode(n)
    };
  };
var peg$f201 = function(s, v) { return foldStringKey([ s, v ]); };
var peg$f202 = function(c) { return keyNode(c); };
var peg$f203 = function(n, a) { return foldStringKey([ n, a ]); };
var peg$f204 = function(m, n) {
    return {
      'type': 'action',
      'variant': keyNode(m),
      'action': n
    };
  };
var peg$f205 = function(n, d, i) {
    return {
      'defer': foldStringKey([ n, d, i ])
    };
  };
var peg$f206 = function(i, d) { return foldStringKey([ i, d ]); };
var peg$f207 = function(s) {
    return {
      'definition': makeArray(s)
    };
  };
var peg$f208 = function(s, ne, n, o, w) {
    return Object.assign({
      'type': 'statement',
      'target': n,
      'on': o,
    }, s, ne, w);
  };
var peg$f209 = function(s, u, i) {
    return Object.assign({
      'variant': keyNode(s),
      'format': keyNode(i)
    }, u);
  };
var peg$f210 = function(u) {
    return {
      'unique': true
    };
  };
var peg$f211 = function(o, t, c) {
    return {
      'type': 'identifier',
      'variant': 'expression',
      'format': 'table',
      'name': t['name'],
      'columns': c
    };
  };
var peg$f212 = function(s, ne, n, cd, o, me, wh, a) {
    return Object.assign({
      'type': 'statement',
      'target': n,
      'on': o,
      'event': cd,
      'by': (isOkay(me) ? me : 'row'),
      'action': makeArray(a)
    }, s, ne, wh);
  };
var peg$f213 = function(s, tmp, t) {
    return Object.assign({
      'variant': keyNode(s),
      'format': keyNode(t)
    }, tmp);
  };
var peg$f214 = function(m, d) {
    return Object.assign({
      'type': 'event'
    }, m, d);
  };
var peg$f215 = function(m) {
    return {
      'occurs': keyNode(m)
    };
  };
var peg$f216 = function(i, o) { return foldStringKey([ i, o ]); };
var peg$f217 = function(o) {
    return {
      'event': keyNode(o)
    };
  };
var peg$f218 = function(s, f) {
    return {
      'event': keyNode(s),
      'of': f
    };
  };
var peg$f219 = function(s, c) { return c; };
var peg$f220 = function(f, e, r) { return keyNode(r); };
var peg$f221 = function(w, e) {
    return {
      'when': e
    };
  };
var peg$f222 = function(s, a, e) { return a; };
var peg$f223 = function(l) { return l; };
var peg$f224 = function(s, ne, n, r) {
    return Object.assign({
      'type': 'statement',
      'target': n,
      'result': r
    }, s, ne);
  };
var peg$f225 = function(n, a) {
    return Object.assign({
      'type': 'identifier',
      'variant': 'expression',
      'format': 'view',
      'name': n['name'],
      'columns': []
    }, a);
  };
var peg$f226 = function(s, tmp, v) {
    return Object.assign({
      'variant': keyNode(s),
      'format': keyNode(v)
    }, tmp);
  };
var peg$f227 = function(s, ne, n, m) {
    return Object.assign({
      'type': 'statement',
      'target': n,
      'result': m
    }, s, ne);
  };
var peg$f228 = function(s, v, t) {
    return {
      'variant': keyNode(s),
      'format': keyNode(v)
    };
  };
var peg$f229 = function(m, a) {
    return Object.assign({
      'type': 'module',
      'variant': 'virtual',
      'name': m
    }, a);
  };
var peg$f230 = function(l) {
    return {
      'args': {
        'type': 'expression',
        'variant': 'list',
        'expression': isOkay(l) ? l : []
      }
    };
  };
var peg$f231 = function(f, b) {
    return flattenAll([ f, b ]).filter((arg) => isOkay(arg));
  };
var peg$f232 = function(a) {
    return a;
  };
var peg$f233 = function(s, q) {
    /**
     * @note Manually copy in the correct variant for the target
     */
    return Object.assign({
      'type': 'statement',
      'target': Object.assign(q, {
        'variant': s['format']
      })
    }, s);
  };
var peg$f234 = function(s, t, i) {
     return Object.assign({
       'variant': keyNode(s),
       'format': t,
       'condition': []
     }, i);
  };
var peg$f235 = function(i, e) {
    return {
      'condition': [{
        'type': 'condition',
        'variant': keyNode(i),
        'condition': {
          'type': 'expression',
          'variant': keyNode(e),
          'operator': keyNode(e)
        }
      }]
    };
  };
var peg$f236 = function(n) {
    return {
      type: 'statement',
      variant: 'variable',
      format: 'show',
      target: keyNode(n),
    };
  };
var peg$f237 = function(n, v) {
    return {
      type: 'statement',
      variant: 'variable',
      format: 'set',
      target: keyNode(n),
      value: v.value || v,
    };
  };
var peg$f238 = function(i, n) { return foldStringKey([ i, n ]); };
var peg$f239 = function(n) {
    return {
      'type': 'identifier',
      'variant': 'database',
      'name': n
    };
  };
var peg$f240 = function(n) {
    return {
      'type': 'identifier',
      'variant': 'schema',
      'name': n
    };
  };
var peg$f241 = function(d, n) {
    return {
      'type': 'identifier',
      // TODO: Should this be `table function` since it is table-function name
        'variant': 'function',
        'name': foldStringWord([ d, n ])
      };
    };
  var peg$f242 = function(d, n) {
      const o = {
        'type': 'identifier',
        'variant': 'table',
        'name': n,
      };
      if (d) {
        o.schema = d;
      }
      return o;
    };
  var peg$f243 = function(n, d) { return n; };
  var peg$f244 = function(q, n) {
      return {
        'type': 'identifier',
        'variant': 'column',
        'name': foldStringWord([ q, n ])
      };
    };
  var peg$f245 = function() { return ''; };
  var peg$f246 = function(d, t) { return foldStringWord([ d, t ]); };
  var peg$f247 = function(n) {
      return {
        'type': 'identifier',
        'variant': 'collation',
        'name': n
      };
    };
  var peg$f248 = function(n) {
      return {
        'type': 'identifier',
        'variant': 'savepoint',
        'name': n
      };
    };
  var peg$f249 = function(d, n) {
      return {
        'type': 'identifier',
        'variant': 'index',
        'name': foldStringWord([ d, n ])
      };
    };
  var peg$f250 = function(d, n) {
      return {
        'type': 'identifier',
        'variant': 'trigger',
        'name': foldStringWord([ d, n ])
      };
    };
  var peg$f251 = function(d, n) {
      return {
        'type': 'identifier',
        'variant': 'view',
        'name': foldStringWord([ d, n ])
      };
    };
  var peg$f252 = function(d, n) {
      return {
        'type': 'identifier',
        'variant': 'pragma',
        'name': foldStringWord([ d, n ])
      };
    };
  var peg$f253 = function(d) {
      return d;
    };
  var peg$f254 = function(n, a) {
      return Object.assign({
        'type': 'identifier',
        'variant': 'expression',
        'format': 'table',
        'name': n['name'],
        'columns': []
      }, a);
    };
  var peg$f255 = function(n) {
      return {
        'type': 'identifier',
        'variant': 'constraint',
        'format': 'table',
        'name': n
      };
    };
  var peg$f256 = function(n) {
      return {
        'type': 'identifier',
        'variant': 'constraint',
        'format': 'column',
        'name': n
      };
    };
  var peg$f257 = function(t) { return [t, 'text']; };
  var peg$f258 = function(t) { return [t, 'real']; };
  var peg$f259 = function(t) { return [t, 'numeric']; };
  var peg$f260 = function(t) { return [t, 'integer']; };
  var peg$f261 = function(t) { return [t, 'none']; };
  var peg$f262 = function(d, p) { return foldStringWord([ d, p ]); };
  var peg$f263 = function(f, p) {
      return foldStringWord([ f, p ]);
    };
  var peg$f264 = function(u, s) {
    return foldStringWord([ u, s ]).toLowerCase();
  };
  var peg$f265 = function(n) {
     return keyNode(n);
    };
  var peg$f266 = function(n) {
      return textNode(n);
    };
  var peg$f267 = function(n) { return unescape(n, '"'); };
  var peg$f268 = function(n) { return unescape(n, "'"); };
var peg$f269 = function(n) { return unescape(n, '`'); };
  var peg$f270 = function(r) { return keyNode(r); };
  var peg$f271 = function() { return null; };

  var peg$currPos = 0;
  var peg$savedPos = 0;
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
  var peg$expected = [];
  var peg$silentFails = 0;

  var peg$resultsCache = {};

  var peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer();

  var peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function offset() {
    return peg$savedPos;
  }

  function range() {
    return [peg$savedPos, peg$currPos];
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos);
    var endPosDetails = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$begin() {
    peg$expected.push({ pos: peg$currPos, variants: [] });
  }

  function peg$expect(expected) {
    var top = peg$expected[peg$expected.length - 1];

    if (peg$currPos < top.pos) { return; }

    if (peg$currPos > top.pos) {
      top.pos = peg$currPos;
      top.variants = [];
    }

    top.variants.push(expected);
  }

  function peg$end(invert) {
    var expected = peg$expected.pop();
    var top = peg$expected[peg$expected.length - 1];
    var variants = expected.variants;

    if (top.pos !== expected.pos) { return; }

    if (invert) {
      variants = variants.map(function(e) {
        return e.type === "not" ? e.expected : { type: "not", expected: e };
      });
    }

    Array.prototype.push.apply(top.variants, variants);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$buildError() {
    var expected = peg$expected[0];
    var failPos = expected.pos;

    return peg$buildStructuredError(
      expected.variants,
      failPos < input.length ? input.charAt(failPos) : null,
      failPos < input.length
        ? peg$computeLocation(failPos, failPos + 1)
        : peg$computeLocation(failPos, failPos)
    );
  }

  function peg$parsestart() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 0;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseo();
    s2 = peg$parsesemi_optional();
    s3 = peg$parsestmt_list();
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    s4 = peg$parsesemi_optional();
    peg$savedPos = s0;
    s0 = peg$f0(s3);

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestart_streaming() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "start_streaming",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 1;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "start_streaming",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "start_streaming",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseo();
    s2 = peg$parsesemi_optional();
    s3 = peg$parsestmt();
    if (s3 !== peg$FAILED) {
      s4 = peg$parsesemi_optional();
      peg$savedPos = s0;
      s0 = peg$f0(s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "start_streaming",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "start_streaming",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_list() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_list",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 2;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_list",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsestmt();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parsestmt_list_tail();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsestmt_list_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f1(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesemi_optional() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "semi_optional",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 3;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "semi_optional",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "semi_optional",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = [];
    s1 = peg$parsesym_semi();
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsesym_semi();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "semi_optional",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "semi_optional",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesemi_required() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "semi_required",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 4;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "semi_required",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "semi_required",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = [];
    s1 = peg$parsesym_semi();
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsesym_semi();
      }
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "semi_required",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "semi_required",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_list_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_list_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 5;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_list_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_list_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesemi_required();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestmt();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f2(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_list_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_list_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetype_definition() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "type_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 6;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_definition",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsetype_definition_types();
    if (s1 === peg$FAILED) {
      s1 = peg$parsedatatype_custom();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsetype_definition_args();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f3(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetype_definition_types() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "type_definition_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 7;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_definition_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_definition_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedatatype_types();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f4(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_definition_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_definition_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_custom() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_custom",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 8;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_custom",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_custom",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsename();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsedatatype_word_tail();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsedatatype_word_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f5(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_custom",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_custom",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_word_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_word_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 9;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_word_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_word_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (peg$r0.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsename_unquoted();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f6(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_word_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_word_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetype_definition_args() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "type_definition_args",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 10;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_definition_args",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_definition_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseliteral_number_signed();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsedefinition_args_loop();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        s5 = peg$parsesym_pclose();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f7(s2, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_definition_args",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_definition_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedefinition_args_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "definition_args_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 11;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "definition_args_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "definition_args_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseliteral_number_signed();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f8(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "definition_args_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "definition_args_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_value() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_value",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 12;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_value",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseliteral_number_signed();
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_number();
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral_blob();
        if (s0 === peg$FAILED) {
          s0 = peg$parseliteral_null();
          if (s0 === peg$FAILED) {
            s0 = peg$parseliteral_date();
            if (s0 === peg$FAILED) {
              s0 = peg$parseliteral_string();
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_value",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_null() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_null",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 13;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_null",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_null",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseNULL();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f9(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_null",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_null",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_date() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_date",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 14;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_date",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_date",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCURRENT_DATE();
    if (s1 === peg$FAILED) {
      s1 = peg$parseCURRENT_TIMESTAMP();
      if (s1 === peg$FAILED) {
        s1 = peg$parseCURRENT_TIME();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f10(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_date",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_date",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_string() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_string",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 15;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_string",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_string",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenumber_sign();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseliteral_string_single();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f11(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_string",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_string",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_string_single() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_string_single",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 16;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_string_single",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_string_single",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_sglquote();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseliteral_string_schar();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseliteral_string_schar();
      }
      s3 = peg$parsesym_sglquote();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f12(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_string_single",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_string_single",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_string_schar() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_string_schar",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 17;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_string_schar",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_string_schar",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    if (input.substr(peg$currPos, 2) === peg$c0) {
      s0 = peg$c0;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      if (peg$r1.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_string_schar",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_string_schar",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_blob() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_blob",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 18;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_blob",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_blob",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (peg$r2.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseliteral_string_single();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f13(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_blob",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_blob",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_text() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_text",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 19;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_text",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_text",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsename_unquoted();
    if (s1 === peg$FAILED) {
      s1 = peg$parsename_dblquoted();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f14(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_text",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_text",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_sign() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "number_sign",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 20;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_sign",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_sign",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_plus();
    if (s1 === peg$FAILED) {
      s1 = peg$parsesym_minus();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f2(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_sign",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_sign",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_number_signed() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_number_signed",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 21;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number_signed",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number_signed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenumber_sign();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseliteral_number();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f15(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number_signed",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number_signed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_number() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_number",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 22;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseliteral_number_hex();
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_number_decimal();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_number_decimal() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_number_decimal",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 23;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number_decimal",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number_decimal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenumber_decimal_node();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenumber_decimal_exponent();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f16(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number_decimal",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number_decimal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_decimal_node() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "number_decimal_node",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 24;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_node",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_node",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsenumber_decimal_full();
    if (s0 === peg$FAILED) {
      s0 = peg$parsenumber_decimal_fraction();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_node",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_node",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_decimal_full() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "number_decimal_full",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 25;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_full",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_full",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsenumber_digit();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsenumber_digit();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenumber_decimal_fraction();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f17(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_full",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_full",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_decimal_fraction() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "number_decimal_fraction",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 26;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_fraction",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_fraction",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_dot();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsenumber_digit();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsenumber_digit();
      }
      peg$savedPos = s0;
      s0 = peg$f18(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_fraction",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_fraction",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_decimal_exponent() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "number_decimal_exponent",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 27;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_exponent",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_exponent",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c1) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (peg$r3.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = [];
      s4 = peg$parsenumber_digit();
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsenumber_digit();
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f19(s1, s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_decimal_exponent",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_decimal_exponent",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_number_hex() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "literal_number_hex",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 28;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number_hex",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number_hex",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c2) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsenumber_hex();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsenumber_hex();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f20(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "literal_number_hex",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_number_hex",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_hex() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "number_hex",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 29;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_hex",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_hex",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    if (peg$r4.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_hex",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_hex",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_digit() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "number_digit",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 30;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_digit",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_digit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    if (peg$r5.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "number_digit",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_digit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebind_parameter() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "bind_parameter",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 31;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsebind_parameter_numbered();
    if (s1 === peg$FAILED) {
      s1 = peg$parsebind_parameter_named();
      if (s1 === peg$FAILED) {
        s1 = peg$parsebind_parameter_tcl();
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f21(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebind_parameter_numbered() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "bind_parameter_numbered",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 32;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter_numbered",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter_numbered",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_quest();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebind_number_id();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f22(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter_numbered",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter_numbered",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebind_number_id() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "bind_number_id",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 33;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_number_id",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_number_id",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (peg$r6.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsenumber_digit();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsenumber_digit();
      }
      peg$savedPos = s0;
      s0 = peg$f23(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_number_id",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_number_id",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebind_parameter_named() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "bind_parameter_named",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 34;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter_named",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter_named",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (peg$r7.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsename_char();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsename_char();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f24(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter_named",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter_named",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebind_parameter_tcl() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "bind_parameter_tcl",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 35;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter_tcl",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter_tcl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 36) {
      s1 = peg$c3;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsename_char();
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c4;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsename_char();
          if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s3 = peg$c4;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
            }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsetcl_suffix();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f25(s1, s2, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bind_parameter_tcl",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bind_parameter_tcl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetcl_suffix() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "tcl_suffix",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 36;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "tcl_suffix",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "tcl_suffix",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsename_dblquoted();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f26(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "tcl_suffix",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "tcl_suffix",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_exists() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_exists",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 37;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_exists",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_exists",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_exists_ne();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseo();
    s3 = peg$parseselect_wrapped();
    if (s3 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f27(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_exists",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_exists",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_exists_ne() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_exists_ne",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 38;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_exists_ne",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_exists_ne",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseEXISTS();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f28(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_exists_ne",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_exists_ne",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_raise() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_raise",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 39;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_raise",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_raise",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseRAISE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsesym_popen();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseexpression_raise_args();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parsesym_pclose();
          if (s7 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s1, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_raise",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_raise",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_raise_args() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_raise_args",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 40;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_raise_args",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_raise_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseraise_args_ignore();
    if (s1 === peg$FAILED) {
      s1 = peg$parseraise_args_message();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f30(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_raise_args",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_raise_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseraise_args_ignore() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "raise_args_ignore",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 41;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "raise_args_ignore",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "raise_args_ignore",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseIGNORE();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f31(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "raise_args_ignore",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "raise_args_ignore",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseraise_args_message() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "raise_args_message",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 42;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "raise_args_message",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "raise_args_message",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseROLLBACK();
    if (s1 === peg$FAILED) {
      s1 = peg$parseABORT();
      if (s1 === peg$FAILED) {
        s1 = peg$parseFAIL();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsesym_comma();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseerror_message();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f32(s1, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "raise_args_message",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "raise_args_message",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_root() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_root",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 43;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_root",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_root",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsebind_parameter();
    if (s0 === peg$FAILED) {
      s0 = peg$parsefunction_call();
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral_value();
        if (s0 === peg$FAILED) {
          s0 = peg$parseid_column();
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_root",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_root",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_wrapped() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_wrapped",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 44;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_wrapped",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_wrapped",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parsesym_pclose();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f33(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_wrapped",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_wrapped",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_recur() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_recur",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 45;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_recur",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_recur",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseexpression_wrapped();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_exists();
      if (s0 === peg$FAILED) {
        s0 = peg$parseexpression_cast();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpression_case();
          if (s0 === peg$FAILED) {
            s0 = peg$parseexpression_raise();
            if (s0 === peg$FAILED) {
              s0 = peg$parseexpression_root();
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_recur",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_recur",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_unary_collate() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_unary_collate",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 46;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_unary_collate",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_unary_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_recur();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression_collate();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f34(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_recur();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_unary_collate",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_unary_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_unary() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_unary",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 47;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_unary",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_unary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_unary_op();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression_unary_collate();
      if (s3 === peg$FAILED) {
        s3 = peg$parseexpression();
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f35(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_unary_collate();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_unary",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_unary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_unary_op() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_unary_op",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 48;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_unary_op",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_unary_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_tilde();
    if (s0 === peg$FAILED) {
      s0 = peg$parsesym_minus();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesym_plus();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseexpression_is_not();
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$begin();
            s4 = peg$parseEXISTS();
            peg$end(true);
            if (s4 === peg$FAILED) {
              s3 = undefined;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_unary_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_unary_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_collate() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_collate",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 49;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_collate",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecolumn_collate();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f36(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_collate",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_concat() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_concat",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 50;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_concat",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_concat",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_unary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parsebinary_concat();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_unary();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        s5 = peg$parsebinary_concat();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression_unary();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_concat",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_concat",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_multiply() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_multiply",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 51;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_multiply",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_multiply",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_concat();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parseexpression_multiply_op();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_concat();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        s5 = peg$parseexpression_multiply_op();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression_concat();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_multiply",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_multiply",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_multiply_op() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_multiply_op",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 52;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_multiply_op",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_multiply_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsebinary_multiply();
    if (s0 === peg$FAILED) {
      s0 = peg$parsebinary_divide();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebinary_mod();
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_multiply_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_multiply_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_add() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_add",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 53;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_add",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_add",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_multiply();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parseexpression_add_op();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_multiply();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        s5 = peg$parseexpression_add_op();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression_multiply();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_add",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_add",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_add_op() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_add_op",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 54;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_add_op",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_add_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsebinary_plus();
    if (s0 === peg$FAILED) {
      s0 = peg$parsebinary_minus();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_add_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_add_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_shift() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_shift",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 55;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_shift",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_shift",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_add();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parseexpression_shift_op();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_add();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        s5 = peg$parseexpression_shift_op();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression_add();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_shift",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_shift",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_shift_op() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_shift_op",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 56;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_shift_op",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_shift_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsebinary_left();
    if (s0 === peg$FAILED) {
      s0 = peg$parsebinary_right();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebinary_and();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsebinary_or();
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$begin();
            s4 = peg$parsebinary_or();
            peg$end(true);
            if (s4 === peg$FAILED) {
              s3 = undefined;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_shift_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_shift_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_compare() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_compare",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 57;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_compare",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_compare",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_shift();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parseexpression_compare_op();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_shift();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        s5 = peg$parseexpression_compare_op();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression_shift();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_compare",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_compare",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_compare_op() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_compare_op",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 58;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_compare_op",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_compare_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsebinary_lte();
    if (s0 === peg$FAILED) {
      s0 = peg$parsebinary_gte();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsebinary_lt();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$begin();
          s4 = peg$parseexpression_shift_op();
          peg$end(true);
          if (s4 === peg$FAILED) {
            s3 = undefined;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsebinary_gt();
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$begin();
            s4 = peg$parseexpression_shift_op();
            peg$end(true);
            if (s4 === peg$FAILED) {
              s3 = undefined;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_compare_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_compare_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_equiv() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_equiv",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 59;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_compare();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpression_equiv_tails();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseexpression_equiv_tails();
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_equiv_tails() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_equiv_tails",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 60;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv_tails",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv_tails",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseo();
    s2 = peg$parseexpression_equiv_null_op();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f38(s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseo();
      s2 = peg$parseexpression_equiv_op();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parseexpression_compare();
        if (s4 !== peg$FAILED) {
          s1 = [s1, s2, s3, s4];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv_tails",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv_tails",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_equiv_null_op() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_equiv_null_op",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 61;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv_null_op",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv_null_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c5) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c6) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f39();
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseISNULL();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f40();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNOTNULL();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f39();
        }
        s0 = s1;
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv_null_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv_null_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_equiv_op() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_equiv_op",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 62;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv_op",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsebinary_lang_isnt();
    if (s0 === peg$FAILED) {
      s0 = peg$parsebinary_notequal_a();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebinary_notequal_b();
        if (s0 === peg$FAILED) {
          s0 = peg$parsebinary_equal();
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_equiv_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_equiv_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_cast() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_cast",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 63;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_cast",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_cast",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCAST();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsesym_popen();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseexpression();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseo();
          s6 = peg$parsetype_alias();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseo();
            s8 = peg$parsesym_pclose();
            if (s8 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f41(s1, s4, s6);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_cast",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_cast",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetype_alias() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "type_alias",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 64;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_alias",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_alias",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseAS();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsetype_definition();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f42(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "type_alias",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "type_alias",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_case() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_case",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 65;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_case",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_case",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCASE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsecase_expression();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseo();
      s5 = [];
      s6 = peg$parseexpression_case_when();
      if (s6 !== peg$FAILED) {
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$parseexpression_case_when();
        }
      } else {
        s5 = peg$FAILED;
      }
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_case_else();
        if (s7 === peg$FAILED) {
          s7 = null;
        }
        s8 = peg$parseo();
        s9 = peg$parseEND();
        if (s9 !== peg$FAILED) {
          s10 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f43(s1, s3, s5, s7);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_case",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_case",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecase_expression() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "case_expression",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 66;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "case_expression",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "case_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$parseWHEN();
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f44(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "case_expression",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "case_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_case_when() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_case_when",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 67;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_case_when",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_case_when",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseWHEN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseTHEN();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression();
          if (s7 !== peg$FAILED) {
            s8 = peg$parseo();
            peg$savedPos = s0;
            s0 = peg$f45(s1, s3, s7);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_case_when",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_case_when",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_case_else() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_case_else",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 68;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_case_else",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_case_else",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseELSE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f46(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_case_else",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_case_else",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_postfix() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_postfix",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 69;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_postfix",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_postfix",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_equiv();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression_postfix_tail();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f47(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_equiv();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_postfix",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_postfix",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_postfix_tail() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_postfix_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 70;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_postfix_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_postfix_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseexpression_in();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression_between();
      if (s0 === peg$FAILED) {
        s0 = peg$parseexpression_like();
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_postfix_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_postfix_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_like() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_like",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 71;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_like",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_like",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseLIKE();
    if (s2 === peg$FAILED) {
      s2 = peg$parseGLOB();
      if (s2 === peg$FAILED) {
        s2 = peg$parseREGEXP();
        if (s2 === peg$FAILED) {
          s2 = peg$parseMATCH();
        }
      }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s4 = peg$parseexpression();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseo();
        s6 = peg$parseexpression_escape();
        if (s6 === peg$FAILED) {
          s6 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f48(s1, s2, s4, s6);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_like",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_like",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_escape() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_escape",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 72;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_escape",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_escape",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseESCAPE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f49(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_escape",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_escape",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_between() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_between",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 73;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_between",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_between",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseBETWEEN();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s4 = peg$parseexpression_between_tail();
      if (s4 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f50(s1, s2, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_between",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_between",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_between_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_between_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 74;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_between_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_between_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_postfix();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseo();
      s4 = peg$parseAND();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseo();
        s6 = peg$parseexpression_postfix();
        if (s6 !== peg$FAILED) {
          s3 = [s3, s4, s5, s6];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f51(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_between_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_between_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_is_not() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_is_not",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 75;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_is_not",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_is_not",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseNOT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f52(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_is_not",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_is_not",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_in() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_in",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 76;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_in",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_in",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseIN();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s4 = peg$parseexpression_in_target();
      if (s4 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f53(s1, s2, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_in",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_in",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_in_target() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_in_target",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 77;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_in_target",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_in_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseexpression_list_or_select();
    if (s0 === peg$FAILED) {
      s0 = peg$parseid_table();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_in_target",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_in_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_list_or_select() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_list_or_select",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 78;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_or_select",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_or_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestmt_select_full();
      if (s2 === peg$FAILED) {
        s2 = peg$parseexpression_list();
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsesym_pclose();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f54(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_or_select",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_or_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_and() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_and",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 79;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_and",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_and",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_postfix();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parseAND();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_postfix();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        s5 = peg$parseAND();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression_postfix();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_and",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_and",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 80;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_and();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parseOR();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        s7 = peg$parseexpression_and();
        if (s7 !== peg$FAILED) {
          s4 = [s4, s5, s6, s7];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        s5 = peg$parseOR();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseexpression_and();
          if (s7 !== peg$FAILED) {
            s4 = [s4, s5, s6, s7];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f37(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_list() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_list",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 81;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_list_loop();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseo();
    peg$savedPos = s0;
    s0 = peg$f55(s1);

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_list_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_list_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 82;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parseexpression_list_rest();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseexpression_list_rest();
      }
      peg$savedPos = s0;
      s0 = peg$f56(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_list_rest() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_list_rest",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 83;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_rest",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_rest",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f54(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_rest",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_rest",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsefunction_call() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "function_call",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 84;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "function_call",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "function_call",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_function();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsesym_popen();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsefunction_call_args();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        s5 = peg$parseo();
        s6 = peg$parsesym_pclose();
        if (s6 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f57(s1, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "function_call",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "function_call",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsefunction_call_args() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "function_call_args",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 85;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "function_call_args",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "function_call_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_star();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f58(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseargs_list_distinct();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      s2 = peg$parseexpression_list();
      peg$savedPos = peg$currPos;
      s3 = peg$f59(s1, s2);
      if (s3) {
        s3 = undefined;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f60(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "function_call_args",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "function_call_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseargs_list_distinct() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "args_list_distinct",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 86;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "args_list_distinct",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "args_list_distinct",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDISTINCT();
    if (s1 === peg$FAILED) {
      s1 = peg$parseALL();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f61(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "args_list_distinct",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "args_list_distinct",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseerror_message() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "error_message",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 87;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "error_message",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "error_message",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseliteral_string();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f62(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "error_message",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "error_message",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 88;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    rule$expects(peg$e0);
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsestmt_modifier();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parsestmt_nodes();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f63(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_modifier() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_modifier",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 89;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_modifier",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseEXPLAIN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsemodifier_query();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f64(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_modifier",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsemodifier_query() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "modifier_query",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 90;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "modifier_query",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "modifier_query",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseQUERY();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsePLAN();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f65(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "modifier_query",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "modifier_query",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_nodes() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_nodes",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 91;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_nodes",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_nodes",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsestmt_crud();
    if (s0 === peg$FAILED) {
      s0 = peg$parsestmt_create();
      if (s0 === peg$FAILED) {
        s0 = peg$parsestmt_drop();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestmt_begin();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestmt_commit();
            if (s0 === peg$FAILED) {
              s0 = peg$parsestmt_alter();
              if (s0 === peg$FAILED) {
                s0 = peg$parsestmt_rollback();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsestmt_savepoint();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsestmt_release();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsestmt_sqlite();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsestmt_set();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsestmt_show();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_nodes",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_nodes",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_commit() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_commit",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 92;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_commit",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_commit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCOMMIT();
    if (s1 === peg$FAILED) {
      s1 = peg$parseEND();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsecommit_transaction();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f66(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_commit",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_commit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_begin() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_begin",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 93;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_begin",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_begin",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseBEGIN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsestmt_begin_modifier();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parsecommit_transaction();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      s5 = peg$parsesavepoint_name();
      if (s5 === peg$FAILED) {
        s5 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f67(s1, s3, s4, s5);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_begin",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_begin",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecommit_transaction() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "commit_transaction",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 94;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "commit_transaction",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "commit_transaction",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseTRANSACTION();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f68(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "commit_transaction",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "commit_transaction",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_begin_modifier() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_begin_modifier",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 95;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_begin_modifier",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_begin_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDEFERRED();
    if (s1 === peg$FAILED) {
      s1 = peg$parseIMMEDIATE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseEXCLUSIVE();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f69(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_begin_modifier",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_begin_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_rollback() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_rollback",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 96;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_rollback",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_rollback",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseROLLBACK();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsecommit_transaction();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parserollback_savepoint();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f70(s1, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_rollback",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_rollback",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parserollback_savepoint() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "rollback_savepoint",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 97;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "rollback_savepoint",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "rollback_savepoint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseTO();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s2 = [s2, s3];
      s1 = s2;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parsesavepoint_alt();
    if (s2 === peg$FAILED) {
      s2 = null;
    }
    s3 = peg$parsesavepoint_name();
    if (s3 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f33(s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "rollback_savepoint",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "rollback_savepoint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesavepoint_name() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "savepoint_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 98;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "savepoint_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "savepoint_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_savepoint();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f71(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "savepoint_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "savepoint_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesavepoint_alt() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "savepoint_alt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 99;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "savepoint_alt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "savepoint_alt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseSAVEPOINT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f72(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "savepoint_alt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "savepoint_alt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_savepoint() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_savepoint",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 100;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_savepoint",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_savepoint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesavepoint_alt();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesavepoint_name();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f73(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_savepoint",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_savepoint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_release() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_release",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 101;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_release",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_release",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseRELEASE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsesavepoint_alt();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parsesavepoint_name();
      if (s4 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f74(s1, s3, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_release",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_release",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_alter() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_alter",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 102;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_alter",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_alter",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsealter_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseid_table();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsealter_action();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f75(s1, s2, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_alter",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_alter",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealter_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "alter_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 103;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseALTER();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseTABLE();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f76(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealter_action() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "alter_action",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 104;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_action",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsealter_action_rename();
    if (s0 === peg$FAILED) {
      s0 = peg$parsealter_action_add();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_action",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealter_action_rename() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "alter_action_rename",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 105;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_action_rename",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action_rename",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseRENAME();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseTO();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseid_table();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f77(s1, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_action_rename",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action_rename",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealter_action_add() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "alter_action_add",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 106;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_action_add",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action_add",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseADD();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseaction_add_modifier();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parsesource_def_column();
      if (s4 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f78(s1, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alter_action_add",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action_add",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaction_add_modifier() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "action_add_modifier",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 107;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_add_modifier",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_add_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCOLUMN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f72(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_add_modifier",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_add_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_crud() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_crud",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 108;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_crud",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_crud",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsestmt_core_with();
    s2 = peg$parsestmt_crud_types();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f79(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_crud",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_crud",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_with() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_with",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 109;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_with",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_with",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseclause_with();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseo();
    peg$savedPos = s0;
    s0 = peg$f6(s1);

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_with",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_with",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseclause_with() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "clause_with",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 110;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseWITH();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseclause_with_recursive();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseclause_with_tables();
      if (s4 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f80(s1, s3, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseclause_with_recursive() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "clause_with_recursive",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 111;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with_recursive",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with_recursive",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseRECURSIVE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f72(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with_recursive",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with_recursive",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseclause_with_tables() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "clause_with_tables",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 112;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with_tables",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with_tables",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_cte();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parseclause_with_loop();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseclause_with_loop();
      }
      peg$savedPos = s0;
      s0 = peg$f81(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with_tables",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with_tables",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseclause_with_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "clause_with_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 113;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_cte();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f54(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "clause_with_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "clause_with_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_cte() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_cte",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 114;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_cte",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_cte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_cte();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseselect_alias();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f82(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_cte",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_cte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_alias() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_alias",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 115;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_alias",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_alias",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseAS();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseselect_wrapped();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f83(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_alias",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_alias",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_wrapped() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_wrapped",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 116;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_wrapped",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_wrapped",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestmt_select_full();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsesym_pclose();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f0(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_wrapped",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_wrapped",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_select_full() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_select_full",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 117;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_select_full",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_select_full",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsestmt_core_with();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestmt_select();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f84(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_select_full",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_select_full",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_sqlite() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_sqlite",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 118;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_sqlite",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_sqlite",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsestmt_attach();
    if (s0 === peg$FAILED) {
      s0 = peg$parsestmt_detach();
      if (s0 === peg$FAILED) {
        s0 = peg$parsestmt_vacuum();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestmt_analyze();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestmt_reindex();
            if (s0 === peg$FAILED) {
              s0 = peg$parsestmt_pragma();
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_sqlite",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_sqlite",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_attach() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_attach",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 119;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_attach",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_attach",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseATTACH();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$currPos;
      s4 = peg$parseDATABASE();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseo();
        s4 = [s4, s5];
        s3 = s4;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseexpression();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseo();
        s6 = peg$parseAS();
        if (s6 !== peg$FAILED) {
          s7 = peg$parseo();
          s8 = peg$parseattach_arg();
          if (s8 !== peg$FAILED) {
            s9 = peg$parseo();
            peg$savedPos = s0;
            s0 = peg$f85(s1, s3, s4, s8);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_attach",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_attach",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseattach_arg() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "attach_arg",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 120;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "attach_arg",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "attach_arg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseid_database();
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_null();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebind_parameter();
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "attach_arg",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "attach_arg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_detach() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_detach",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 121;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_detach",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_detach",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDETACH();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$currPos;
      s4 = peg$parseDATABASE();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseo();
        s4 = [s4, s5];
        s3 = s4;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseattach_arg();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f86(s1, s3, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_detach",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_detach",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_vacuum() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_vacuum",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 122;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_vacuum",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_vacuum",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseVACUUM();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsevacuum_target();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f87(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_vacuum",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_vacuum",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevacuum_target() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "vacuum_target",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 123;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "vacuum_target",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "vacuum_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_database();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f88(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "vacuum_target",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "vacuum_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_analyze() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_analyze",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 124;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_analyze",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_analyze",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseANALYZE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseanalyze_arg();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f89(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_analyze",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_analyze",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseanalyze_arg() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "analyze_arg",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 125;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "analyze_arg",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "analyze_arg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 === peg$FAILED) {
      s1 = peg$parseid_index();
      if (s1 === peg$FAILED) {
        s1 = peg$parseid_database();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f90(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "analyze_arg",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "analyze_arg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_reindex() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_reindex",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 126;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_reindex",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_reindex",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseREINDEX();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsereindex_arg();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f89(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_reindex",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_reindex",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereindex_arg() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "reindex_arg",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 127;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reindex_arg",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reindex_arg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 === peg$FAILED) {
      s1 = peg$parseid_index();
      if (s1 === peg$FAILED) {
        s1 = peg$parseid_collation();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f91(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reindex_arg",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reindex_arg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_pragma() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_pragma",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 128;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_pragma",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_pragma",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsePRAGMA();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseid_pragma();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parsepragma_expression();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f92(s1, s3, s5);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_pragma",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_pragma",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepragma_expression() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "pragma_expression",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 129;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_expression",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsepragma_value();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsesym_pclose();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f93(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsesym_equal();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepragma_value();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f93(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_expression",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepragma_value() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "pragma_value",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 130;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsepragma_value_bool();
    if (s0 === peg$FAILED) {
      s0 = peg$parsepragma_value_literal();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepragma_value_name();
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepragma_value_literal() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "pragma_value_literal",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 131;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value_literal",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value_literal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseliteral_number_signed();
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_string();
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral_text();
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value_literal",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value_literal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepragma_value_bool() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "pragma_value_bool",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 132;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value_bool",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value_bool",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsepragma_bool_id();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$f94(s1);
      if (s2) {
        s2 = undefined;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f95(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value_bool",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value_bool",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepragma_bool_id() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "pragma_bool_id",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 133;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_bool_id",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_bool_id",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsename_char();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsename_char();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f96(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_bool_id",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_bool_id",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepragma_value_name() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "pragma_value_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 134;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsepragma_bool_id();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f97(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "pragma_value_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pragma_value_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_crud_types() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_crud_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 135;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_crud_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_crud_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsestmt_select();
    if (s0 === peg$FAILED) {
      s0 = peg$parsestmt_insert();
      if (s0 === peg$FAILED) {
        s0 = peg$parsestmt_update();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestmt_delete();
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_crud_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_crud_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_select() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_select",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 136;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_select",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_loop();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsestmt_core_order();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseo();
      s5 = peg$parsestmt_core_limit();
      if (s5 === peg$FAILED) {
        s5 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f98(s1, s3, s5);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_select",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_order() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_order",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 137;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseORDER();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseBY();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parsestmt_core_order_list();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f99(s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_limit() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_limit",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 138;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_limit",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_limit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseLIMIT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parsestmt_core_limit_offset();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f100(s1, s3, s5);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_limit",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_limit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_limit_offset() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_limit_offset",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 139;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_limit_offset",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_limit_offset",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parselimit_offset_variant();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f101(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_limit_offset",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_limit_offset",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselimit_offset_variant() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "limit_offset_variant",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 140;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "limit_offset_variant",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "limit_offset_variant",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parselimit_offset_variant_name();
    if (s0 === peg$FAILED) {
      s0 = peg$parsesym_comma();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "limit_offset_variant",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "limit_offset_variant",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselimit_offset_variant_name() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "limit_offset_variant_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 141;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "limit_offset_variant_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "limit_offset_variant_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseOFFSET();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f72(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "limit_offset_variant_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "limit_offset_variant_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 142;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_parts();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parseselect_loop_union();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseselect_loop_union();
      }
      peg$savedPos = s0;
      s0 = peg$f102(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_loop_union() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_loop_union",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 143;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_loop_union",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_loop_union",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseoperator_compound();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseselect_parts();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f103(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_loop_union",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_loop_union",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_parts() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_parts",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 144;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_parts",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_parts",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseselect_parts_core();
    if (s0 === peg$FAILED) {
      s0 = peg$parseselect_parts_values();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_parts",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_parts",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_parts_core() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_parts_core",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 145;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_parts_core",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_parts_core",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_core_select();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseselect_core_from();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parsestmt_core_where();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseselect_core_group();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f104(s1, s2, s3, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_parts_core",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_parts_core",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_core_select() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_core_select",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 146;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_select",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseSELECT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseselect_modifier();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseo();
      s5 = peg$parseselect_target();
      if (s5 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f105(s3, s5);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_select",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_modifier() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_modifier",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 147;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_modifier",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseselect_modifier_distinct();
    if (s0 === peg$FAILED) {
      s0 = peg$parseselect_modifier_all();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_modifier",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_modifier",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_modifier_distinct() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_modifier_distinct",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 148;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_modifier_distinct",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_modifier_distinct",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDISTINCT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f106(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_modifier_distinct",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_modifier_distinct",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_modifier_all() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_modifier_all",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 149;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_modifier_all",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_modifier_all",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseALL();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f107(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_modifier_all",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_modifier_all",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_target() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_target",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 150;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_target",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_node();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parseselect_target_loop();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseselect_target_loop();
      }
      peg$savedPos = s0;
      s0 = peg$f81(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_target",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_target_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_target_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 151;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_target_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_target_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseselect_node();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f8(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_target_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_target_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_core_from() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_core_from",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 152;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_from",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_from",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseFROM();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseselect_source();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f108(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_from",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_from",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_where() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_where",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 153;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_where",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_where",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseWHERE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f109(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_where",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_where",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_core_group() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_core_group",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 154;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_group",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_group",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseGROUP();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseBY();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseexpression_list();
        s6 = peg$parseo();
        s7 = peg$parseselect_core_having();
        if (s7 === peg$FAILED) {
          s7 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f110(s1, s5, s7);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_group",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_group",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_core_having() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_core_having",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 155;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_having",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_having",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseHAVING();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f111(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_core_having",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_core_having",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_node() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_node",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 156;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseselect_node_star();
    if (s0 === peg$FAILED) {
      s0 = peg$parseselect_node_aliased();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_node_star() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_node_star",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 157;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node_star",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node_star",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_node_star_qualified();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseselect_star();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f112(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node_star",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node_star",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_node_star_qualified() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_node_star_qualified",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 158;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node_star_qualified",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node_star_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsename();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_dot();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f113(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node_star_qualified",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node_star_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_node_aliased() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_node_aliased",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 159;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node_aliased",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node_aliased",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsealias();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f114(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_node_aliased",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_node_aliased",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_source() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_source",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 160;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_source",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_source",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsetable_or_sub();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parsesource_loop_tail();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsesource_loop_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f115(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_source",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_source",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesource_loop_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "source_loop_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 161;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_loop_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_loop_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_cross_clause();
    if (s1 === peg$FAILED) {
      s1 = peg$parseselect_join_clause();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsejoin_condition();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f116(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_loop_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_loop_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_cross_clause() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_cross_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 162;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_cross_clause",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_cross_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsetable_or_sub();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f117(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_cross_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_cross_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_join_clause() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_join_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 163;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_join_clause",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_join_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsejoin_operator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsetable_or_sub();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f118(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_join_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_join_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_or_sub() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_or_sub",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 164;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsetable_or_sub_sub();
    if (s0 === peg$FAILED) {
      s0 = peg$parsebind_parameter();
      if (s0 === peg$FAILED) {
        s0 = peg$parsetable_or_sub_func();
        if (s0 === peg$FAILED) {
          s0 = peg$parsetable_qualified();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetable_or_sub_select();
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_or_sub_func() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_or_sub_func",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 165;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_func",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_func",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_function();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression_list_wrapped();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parsealias();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f119(s1, s3, s5);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_func",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_func",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_qualified() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_qualified",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 166;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_qualified",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsetable_qualified_id();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsetable_or_sub_index_node();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f120(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_qualified",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_qualified_id() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_qualified_id",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 167;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_qualified_id",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_qualified_id",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsealias();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f121(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_qualified_id",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_qualified_id",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_or_sub_index_node() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_or_sub_index_node",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 168;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_index_node",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_index_node",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseindex_node_indexed();
    if (s0 === peg$FAILED) {
      s0 = peg$parseindex_node_none();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_index_node",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_index_node",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_node_indexed() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "index_node_indexed",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 169;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_node_indexed",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_node_indexed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseINDEXED();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseBY();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseid_index();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f122(s1, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_node_indexed",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_node_indexed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_node_none() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "index_node_none",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 170;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_node_none",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_node_none",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseINDEXED();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f123(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_node_none",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_node_none",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_or_sub_sub() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_or_sub_sub",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 171;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_sub",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_sub",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseselect_source();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsesym_pclose();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsealias();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f124(s2, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_sub",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_sub",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_or_sub_select() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_or_sub_select",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 172;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_select",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseselect_wrapped();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsealias();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f125(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_or_sub_select",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_or_sub_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealias() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "alias",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 173;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alias",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alias",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseAS();
    if (s2 !== peg$FAILED) {
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$begin();
      s5 = peg$parsename_char();
      if (s5 === peg$FAILED) {
        s5 = peg$parsereserved_critical_list();
      }
      peg$end(true);
      if (s5 === peg$FAILED) {
        s4 = undefined;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseo();
        s4 = [s4, s5];
        s3 = s4;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parsename();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f126(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "alias",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alias",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_operator() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "join_operator",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 174;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_operator",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_operator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsejoin_operator_natural();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseo();
    s3 = peg$parsejoin_operator_types();
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    s4 = peg$parseJOIN();
    if (s4 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f127(s1, s3, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_operator",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_operator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_operator_natural() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "join_operator_natural",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 175;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_operator_natural",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_operator_natural",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseNATURAL();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f52(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_operator_natural",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_operator_natural",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_operator_types() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "join_operator_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 176;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_operator_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_operator_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseoperator_types_hand();
    if (s0 === peg$FAILED) {
      s0 = peg$parseoperator_types_misc();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_operator_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_operator_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseoperator_types_hand() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "operator_types_hand",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 177;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "operator_types_hand",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "operator_types_hand",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseLEFT();
    if (s1 === peg$FAILED) {
      s1 = peg$parseRIGHT();
      if (s1 === peg$FAILED) {
        s1 = peg$parseFULL();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsetypes_hand_outer();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f128(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "operator_types_hand",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "operator_types_hand",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetypes_hand_outer() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "types_hand_outer",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 178;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "types_hand_outer",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "types_hand_outer",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseOUTER();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f129(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "types_hand_outer",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "types_hand_outer",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseoperator_types_misc() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "operator_types_misc",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 179;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "operator_types_misc",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "operator_types_misc",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseINNER();
    if (s1 === peg$FAILED) {
      s1 = peg$parseCROSS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f129(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "operator_types_misc",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "operator_types_misc",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_condition() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "join_condition",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 180;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_condition",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_condition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsejoin_condition_on();
    if (s1 === peg$FAILED) {
      s1 = peg$parsejoin_condition_using();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f130(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_condition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_condition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_condition_on() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "join_condition_on",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 181;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_condition_on",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_condition_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f131(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_condition_on",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_condition_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_condition_using() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "join_condition_using",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 182;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_condition_using",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_condition_using",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseUSING();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseloop_columns();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f132(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "join_condition_using",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_condition_using",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_parts_values() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_parts_values",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 183;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_parts_values",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_parts_values",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseVALUES();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseinsert_values_list();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f133(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_parts_values",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_parts_values",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_order_list() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_order_list",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 184;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order_list",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsestmt_core_order_list_item();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parsestmt_core_order_list_loop();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsestmt_core_order_list_loop();
      }
      peg$savedPos = s0;
      s0 = peg$f134(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_order_list_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_order_list_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 185;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order_list_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order_list_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestmt_core_order_list_item();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f135(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order_list_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order_list_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_core_order_list_item() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_core_order_list_item",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 186;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order_list_item",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order_list_item",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseprimary_column_dir();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f136(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_core_order_list_item",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_core_order_list_item",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_star() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "select_star",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 187;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_star",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_star",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_star();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "select_star",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_star",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_fallback_types() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_fallback_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 188;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_fallback_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_fallback_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseREPLACE();
    if (s0 === peg$FAILED) {
      s0 = peg$parseROLLBACK();
      if (s0 === peg$FAILED) {
        s0 = peg$parseABORT();
        if (s0 === peg$FAILED) {
          s0 = peg$parseFAIL();
          if (s0 === peg$FAILED) {
            s0 = peg$parseIGNORE();
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_fallback_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_fallback_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_insert() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_insert",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 189;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_insert",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_insert",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseinsert_keyword();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseinsert_target();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f137(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_insert",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_insert",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_keyword() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_keyword",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 190;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseinsert_keyword_ins();
    if (s0 === peg$FAILED) {
      s0 = peg$parseinsert_keyword_repl();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_keyword_ins() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_keyword_ins",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 191;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword_ins",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword_ins",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseINSERT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseinsert_keyword_mod();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f138(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword_ins",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword_ins",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_keyword_repl() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_keyword_repl",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 192;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword_repl",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword_repl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseREPLACE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f139(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword_repl",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword_repl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_keyword_mod() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_keyword_mod",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 193;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword_mod",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword_mod",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseOR();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsestmt_fallback_types();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f140(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_keyword_mod",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_keyword_mod",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_target() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_target",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 194;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_target",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseinsert_into();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseinsert_results();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f141(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_target",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_target",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_into() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_into",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 195;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_into",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_into",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseinsert_into_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseid_cte();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f142(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_into",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_into",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_into_start() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_into_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 196;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_into_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_into_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseINTO();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s1 = [s1, s2];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_into_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_into_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_results() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_results",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 197;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_results",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_results",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseinsert_value();
    if (s1 === peg$FAILED) {
      s1 = peg$parsestmt_select_full();
      if (s1 === peg$FAILED) {
        s1 = peg$parseinsert_default();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f143(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_results",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_results",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseloop_columns() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "loop_columns",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 198;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "loop_columns",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "loop_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseloop_name();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = [];
        s5 = peg$parseloop_column_tail();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseloop_column_tail();
        }
        s5 = peg$parsesym_pclose();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f144(s2, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "loop_columns",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "loop_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseloop_column_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "loop_column_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 199;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "loop_column_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "loop_column_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseloop_name();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "loop_column_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "loop_column_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseloop_name() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "loop_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 200;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "loop_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "loop_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f146(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "loop_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "loop_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_value() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_value",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 201;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_value",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseinsert_value_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseinsert_values_list();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f147(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_value",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_value_start() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_value_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 202;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_value_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_value_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseVALUES();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f72(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_value_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_value_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_values_list() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_values_list",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 203;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_values_list",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_values_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_list_wrapped();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parseinsert_values_loop();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseinsert_values_loop();
      }
      peg$savedPos = s0;
      s0 = peg$f148(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_values_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_values_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_values_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_values_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 204;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_values_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_values_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_list_wrapped();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f54(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_values_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_values_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpression_list_wrapped() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "expression_list_wrapped",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 205;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_wrapped",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_wrapped",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression_list();
      s3 = peg$parseo();
      s4 = peg$parsesym_pclose();
      if (s4 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f149(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "expression_list_wrapped",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expression_list_wrapped",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_default() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "insert_default",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 206;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_default",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_default",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDEFAULT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseVALUES();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f150(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "insert_default",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_default",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseoperator_compound() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "operator_compound",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 207;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "operator_compound",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "operator_compound",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecompound_union();
    if (s1 === peg$FAILED) {
      s1 = peg$parseINTERSECT();
      if (s1 === peg$FAILED) {
        s1 = peg$parseEXCEPT();
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f72(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "operator_compound",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "operator_compound",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecompound_union() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "compound_union",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 208;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "compound_union",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "compound_union",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseUNION();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsecompound_union_all();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f151(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "compound_union",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "compound_union",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecompound_union_all() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "compound_union_all",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 209;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "compound_union_all",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "compound_union_all",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseALL();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f152(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "compound_union_all",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "compound_union_all",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_update() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_update",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 210;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_update",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_update",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseupdate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseupdate_fallback();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parsetable_qualified();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseupdate_set();
        if (s5 !== peg$FAILED) {
          s6 = peg$parsestmt_core_where();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = peg$parsestmt_core_order();
          if (s7 === peg$FAILED) {
            s7 = null;
          }
          s8 = peg$parseo();
          s9 = peg$parsestmt_core_limit();
          if (s9 === peg$FAILED) {
            s9 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f153(s1, s2, s3, s5, s6, s7, s9);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_update",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_update",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseupdate_start() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "update_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 211;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseUPDATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f72(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseupdate_fallback() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "update_fallback",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 212;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_fallback",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_fallback",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseOR();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsestmt_fallback_types();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f154(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_fallback",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_fallback",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseupdate_set() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "update_set",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 213;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_set",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_set",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseSET();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseupdate_columns();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f155(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_set",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_set",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseupdate_columns() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "update_columns",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 214;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_columns",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseupdate_column();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseupdate_columns_tail();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseupdate_columns_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f148(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_columns",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseupdate_columns_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "update_columns_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 215;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_columns_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_columns_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseo();
    s2 = peg$parsesym_comma();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseupdate_column();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_columns_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_columns_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseupdate_column() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "update_column",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 216;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_column",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_column();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsesym_equal();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseexpression();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f156(s1, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "update_column",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_delete() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_delete",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 217;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_delete",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_delete",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedelete_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsetable_qualified();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parsestmt_core_where();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        s5 = peg$parsestmt_core_order();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        s6 = peg$parsestmt_core_limit();
        if (s6 === peg$FAILED) {
          s6 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f157(s1, s2, s4, s5, s6);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_delete",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_delete",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedelete_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "delete_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 218;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "delete_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "delete_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDELETE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseFROM();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f72(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "delete_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "delete_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_create() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_create",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 219;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_create",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_create",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsecreate_table_only();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecreate_index_only();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecreate_trigger_only();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecreate_view_only();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecreate_virtual_only();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecreate_database_only();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecreate_schema_only();
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_create",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_create",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_start() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 220;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCREATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f72(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_table_only() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_table_only",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 221;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table_only",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseINDEX();
      if (s4 === peg$FAILED) {
        s4 = peg$parseTRIGGER();
        if (s4 === peg$FAILED) {
          s4 = peg$parseVIEW();
          if (s4 === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDATABASE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseSCHEMA();
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_table();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table_only",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_index_only() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_index_only",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 222;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_index_only",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 === peg$FAILED) {
        s4 = peg$parseTRIGGER();
        if (s4 === peg$FAILED) {
          s4 = peg$parseVIEW();
          if (s4 === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDATABASE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseSCHEMA();
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_index();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_index_only",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_trigger_only() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_trigger_only",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 223;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_trigger_only",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_trigger_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 === peg$FAILED) {
          s4 = peg$parseVIEW();
          if (s4 === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDATABASE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseSCHEMA();
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_trigger();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_trigger_only",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_trigger_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_view_only() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_view_only",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 224;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_view_only",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_view_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 === peg$FAILED) {
          s4 = peg$parseTRIGGER();
          if (s4 === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDATABASE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseSCHEMA();
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_view();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_view_only",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_view_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_virtual_only() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_virtual_only",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 225;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_virtual_only",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_virtual_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 === peg$FAILED) {
          s4 = peg$parseTRIGGER();
          if (s4 === peg$FAILED) {
            s4 = peg$parseVIEW();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDATABASE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseSCHEMA();
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_virtual();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_virtual_only",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_virtual_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_database_only() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_database_only",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 226;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_database_only",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_database_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 === peg$FAILED) {
          s4 = peg$parseTRIGGER();
          if (s4 === peg$FAILED) {
            s4 = peg$parseVIEW();
            if (s4 === peg$FAILED) {
              s4 = peg$parseVIRTUAL();
              if (s4 === peg$FAILED) {
                s4 = peg$parseSCHEMA();
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_database();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_database_only",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_database_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_schema_only() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_schema_only",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 227;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_schema_only",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_schema_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 === peg$FAILED) {
          s4 = peg$parseTRIGGER();
          if (s4 === peg$FAILED) {
            s4 = peg$parseVIEW();
            if (s4 === peg$FAILED) {
              s4 = peg$parseVIRTUAL();
              if (s4 === peg$FAILED) {
                s4 = peg$parseDATABASE();
              }
            }
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_schema();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_schema_only",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_schema_only",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_schema() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_schema",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 228;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_schema",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_schema",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSCHEMA();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parseid_schema();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f158(s1, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_schema",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_schema",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_database() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_database",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 229;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_database",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_database",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseDATABASE();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parseid_database();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f159(s1, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_database",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_database",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_table() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_table",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 230;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_table_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseid_table();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parsecreate_table_source();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f160(s1, s2, s3, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_table_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_table_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 231;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_tmp();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseTABLE();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f161(s1, s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_core_tmp() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_core_tmp",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 232;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_core_tmp",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_core_tmp",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseTEMPORARY();
    if (s1 === peg$FAILED) {
      s1 = peg$parseTEMP();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f162(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_core_tmp",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_core_tmp",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_core_ine() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_core_ine",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 233;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_core_ine",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_core_ine",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseIF();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression_is_not();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseEXISTS();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f163(s1, s3, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_core_ine",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_core_ine",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_table_source() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_table_source",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 234;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table_source",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_source",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsetable_source_def();
    if (s0 === peg$FAILED) {
      s0 = peg$parsetable_source_select();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_table_source",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_source",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_source_def() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_source_def",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 235;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_source_def",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_source_def",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesource_def_loop();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsesource_tbl_loop();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsesource_tbl_loop();
        }
        s4 = peg$parsesym_pclose();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsesource_def_rowid();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f164(s2, s3, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_source_def",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_source_def",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesource_def_rowid() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "source_def_rowid",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 236;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_rowid",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_rowid",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseWITHOUT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseROWID();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f165(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_rowid",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_rowid",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesource_def_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "source_def_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 237;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesource_def_column();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parsesource_def_tail();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsesource_def_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f148(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesource_def_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "source_def_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 238;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesource_def_column();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f68(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesource_tbl_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "source_tbl_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 239;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_tbl_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_tbl_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parsetable_constraint();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f166(s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_tbl_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_tbl_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesource_def_column() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "source_def_column",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 240;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_column",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesource_def_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsecolumn_type();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parsecolumn_constraints();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f167(s1, s3, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_column",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesource_def_name() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "source_def_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 241;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsename();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parseo();
      peg$end(false);
      peg$currPos = s2;
      s2 = undefined;
      peg$savedPos = s0;
      s0 = peg$f33(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$begin();
      s2 = peg$parsecolumn_type();
      if (s2 === peg$FAILED) {
        s2 = peg$parsecolumn_constraint();
        if (s2 === peg$FAILED) {
          s2 = peg$parsetable_constraint();
        }
      }
      peg$end(true);
      if (s2 === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseo();
        s3 = peg$parsename_reserved();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f33(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "source_def_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "source_def_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_type() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_type",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 242;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_type",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsetype_definition();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f168(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraints() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraints",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 243;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraints",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraints",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecolumn_constraint();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsecolumn_constraint_tail();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsecolumn_constraint_tail();
      }
      s3 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f148(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraints",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraints",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 244;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseo();
    s2 = peg$parsecolumn_constraint();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f145(s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 245;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseconstraint_name();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parsecolumn_constraint_types();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseconstraint_name();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f169(s1, s2, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseconstraint_name() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "constraint_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 246;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseconstraint_name_loop();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseconstraint_name_loop();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f170(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseconstraint_name_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "constraint_name_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 247;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_name_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_name_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCONSTRAINT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsename();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f171(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_name_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_name_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_types() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 248;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsecolumn_constraint_primary();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecolumn_constraint_null();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecolumn_constraint_check();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecolumn_constraint_default();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecolumn_constraint_collate();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecolumn_constraint_foreign();
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_foreign() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_foreign",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 249;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_foreign",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_foreign",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseforeign_clause();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f172(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_foreign",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_foreign",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_primary() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_primary",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 250;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_primary",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_primary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecol_primary_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseprimary_column_dir();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseprimary_conflict();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parsecol_primary_auto();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f173(s1, s2, s3, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_primary",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_primary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecol_primary_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "col_primary_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 251;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "col_primary_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "col_primary_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsePRIMARY();
    if (s1 === peg$FAILED) {
      s1 = peg$parsePRAGMA();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseKEY();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f174(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "col_primary_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "col_primary_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecol_primary_auto() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "col_primary_auto",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 252;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "col_primary_auto",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "col_primary_auto",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseAUTOINCREMENT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f175(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "col_primary_auto",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "col_primary_auto",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_null() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_null",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 253;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_null",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_null",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseconstraint_null_types();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseprimary_conflict();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f176(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_null",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_null",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseconstraint_null_types() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "constraint_null_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 254;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_null_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_null_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseconstraint_null_value();
    if (s1 === peg$FAILED) {
      s1 = peg$parseUNIQUE();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f129(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_null_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_null_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseconstraint_null_value() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "constraint_null_value",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 255;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_null_value",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_null_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseNULL();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f177(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_null_value",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_null_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_check() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_check",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 256;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_check",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_check",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseconstraint_check();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_check",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_check",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_default() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_default",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 257;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_default",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_default",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDEFAULT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsecolumn_default_values();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f178(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_default",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_default",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_default_values() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_default_values",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 258;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_default_values",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_default_values",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseexpression_wrapped();
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_number_signed();
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral_value();
        if (s0 === peg$FAILED) {
          s0 = peg$parseliteral_text();
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_default_values",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_default_values",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint_collate() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_constraint_collate",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 259;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_collate",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecolumn_collate();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f179(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_constraint_collate",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_constraint() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_constraint",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 260;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseconstraint_name();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parsetable_constraint_types();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s4 = peg$parseconstraint_name();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f180(s1, s2, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_constraint_types() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_constraint_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 261;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsetable_constraint_foreign();
    if (s0 === peg$FAILED) {
      s0 = peg$parsetable_constraint_primary();
      if (s0 === peg$FAILED) {
        s0 = peg$parsetable_constraint_check();
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_constraint_check() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_constraint_check",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 262;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_check",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_check",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseconstraint_check();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f181(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_check",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_check",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_constraint_primary() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_constraint_primary",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 263;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_primary",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_primary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseprimary_columns_table();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseprimary_conflict();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f182(s1, s3, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_primary",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_primary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_start() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 264;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_start_normal();
    if (s1 === peg$FAILED) {
      s1 = peg$parseprimary_start_unique();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f183(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_start_normal() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_start_normal",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 265;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_start_normal",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_start_normal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsePRIMARY();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseKEY();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f184(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_start_normal",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_start_normal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_start_unique() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_start_unique",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 266;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_start_unique",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_start_unique",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseUNIQUE();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f185(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_start_unique",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_start_unique",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_columns() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_columns",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 267;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_columns",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseprimary_column();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = [];
        s5 = peg$parseprimary_column_tail();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseprimary_column_tail();
        }
        s5 = peg$parsesym_pclose();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f186(s2, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_columns",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_columns_index() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_columns_index",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 268;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_columns_index",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_columns_index",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_columns();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f187(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_columns_index",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_columns_index",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_columns_table() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_columns_table",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 269;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_columns_table",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_columns_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_columns();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f188(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_columns_table",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_columns_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_column_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_column_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 270;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseprimary_column();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f145(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_column() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_column",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 271;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_column_types();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseprimary_column_dir();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parsecol_primary_auto();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f189(s1, s3, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_column_types() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_column_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 272;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseloop_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$currPos;
      s4 = peg$parseo();
      s5 = peg$parsesym_semi();
      if (s5 === peg$FAILED) {
        s5 = peg$parsesym_pclose();
        if (s5 === peg$FAILED) {
          s5 = peg$parseprimary_column_dir();
        }
      }
      if (s5 !== peg$FAILED) {
        s4 = [s4, s5];
        s3 = s4;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      peg$end(false);
      if (s3 !== peg$FAILED) {
        peg$currPos = s2;
        s2 = undefined;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f33(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseexpression();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_collate() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_collate",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 273;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_collate",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsecolumn_collate_loop();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsecolumn_collate_loop();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f190(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_collate",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_collate",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_collate_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_collate_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 274;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_collate_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_collate_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCOLLATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseid_collation();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f33(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_collate_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_collate_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_column_dir() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_column_dir",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 275;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column_dir",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column_dir",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseASC();
    if (s1 === peg$FAILED) {
      s1 = peg$parseDESC();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f191(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_column_dir",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_column_dir",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_conflict() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_conflict",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 276;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_conflict",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_conflict",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_conflict_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsestmt_fallback_types();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f192(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_conflict",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_conflict",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary_conflict_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "primary_conflict_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 277;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_conflict_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_conflict_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseCONFLICT();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f193(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "primary_conflict_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary_conflict_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseconstraint_check() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "constraint_check",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 278;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_check",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_check",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCHECK();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression_wrapped();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f194(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "constraint_check",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_check",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_constraint_foreign() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_constraint_foreign",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 279;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_foreign",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_foreign",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseforeign_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseloop_columns();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseforeign_clause();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f195(s1, s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_constraint_foreign",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_constraint_foreign",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 280;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseFOREIGN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseKEY();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f196(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_clause() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 281;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_clause",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseforeign_references();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseforeign_actions();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseforeign_deferrable();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f197(s1, s2, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_references() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_references",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 282;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_references",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_references",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseREFERENCES();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseid_cte();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f198(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_references",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_references",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_actions() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_actions",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 283;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_actions",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_actions",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseforeign_action();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parseforeign_actions_tail();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseforeign_actions_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f199(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_actions",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_actions",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_actions_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_actions_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 284;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_actions_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_actions_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseforeign_action();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f152(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_actions_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_actions_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_action() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_action",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 285;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_action",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseforeign_action_on();
    if (s0 === peg$FAILED) {
      s0 = peg$parseforeign_action_match();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_action",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_action_on() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_action_on",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 286;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_action_on",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_action_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseDELETE();
      if (s3 === peg$FAILED) {
        s3 = peg$parseUPDATE();
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseaction_on_action();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f200(s1, s3, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_action_on",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_action_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaction_on_action() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "action_on_action",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 287;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_on_action",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_on_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseon_action_set();
    if (s0 === peg$FAILED) {
      s0 = peg$parseon_action_cascade();
      if (s0 === peg$FAILED) {
        s0 = peg$parseon_action_none();
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_on_action",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_on_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseon_action_set() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "on_action_set",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 288;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "on_action_set",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_action_set",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseSET();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseNULL();
      if (s3 === peg$FAILED) {
        s3 = peg$parseDEFAULT();
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f201(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "on_action_set",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_action_set",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseon_action_cascade() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "on_action_cascade",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 289;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "on_action_cascade",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_action_cascade",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseCASCADE();
    if (s1 === peg$FAILED) {
      s1 = peg$parseRESTRICT();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f202(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "on_action_cascade",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_action_cascade",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseon_action_none() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "on_action_none",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 290;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "on_action_none",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_action_none",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseNO();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseACTION();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f203(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "on_action_none",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_action_none",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_action_match() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_action_match",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 291;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_action_match",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_action_match",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseMATCH();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsename();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f204(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_action_match",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_action_match",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseforeign_deferrable() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "foreign_deferrable",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 292;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_deferrable",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_deferrable",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseDEFERRABLE();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s4 = peg$parsedeferrable_initially();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f205(s1, s2, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "foreign_deferrable",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "foreign_deferrable",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedeferrable_initially() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "deferrable_initially",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 293;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "deferrable_initially",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "deferrable_initially",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseINITIALLY();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseDEFERRED();
      if (s3 === peg$FAILED) {
        s3 = peg$parseIMMEDIATE();
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f206(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "deferrable_initially",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "deferrable_initially",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_source_select() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "table_source_select",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 294;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_source_select",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_source_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_as_select();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f207(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "table_source_select",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_source_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_index() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_index",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 295;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_index",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_index_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseid_index();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseindex_on();
        if (s5 !== peg$FAILED) {
          s6 = peg$parsestmt_core_where();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f208(s1, s2, s3, s5, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_index",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_index_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_index_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 296;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_index_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseindex_unique();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseINDEX();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f209(s1, s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_index_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_unique() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "index_unique",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 297;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_unique",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_unique",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseUNIQUE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f210(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_unique",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_unique",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_on() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "index_on",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 298;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_on",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseid_table();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseprimary_columns_index();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f211(s1, s3, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "index_on",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_trigger() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_trigger",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 299;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_trigger",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_trigger",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_trigger_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseid_trigger();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseo();
      s5 = peg$parsetrigger_conditions();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseON();
        if (s6 !== peg$FAILED) {
          s7 = peg$parseo();
          s8 = peg$parseid_table();
          if (s8 !== peg$FAILED) {
            s9 = peg$parseo();
            s10 = peg$parsetrigger_foreach();
            if (s10 === peg$FAILED) {
              s10 = null;
            }
            s11 = peg$parsetrigger_when();
            if (s11 === peg$FAILED) {
              s11 = null;
            }
            s12 = peg$parsetrigger_action();
            if (s12 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f212(s1, s2, s3, s5, s8, s10, s11, s12);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_trigger",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_trigger",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_trigger_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_trigger_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 300;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_trigger_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_trigger_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_tmp();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseTRIGGER();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f213(s1, s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_trigger_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_trigger_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_conditions() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_conditions",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 301;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_conditions",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_conditions",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsetrigger_apply_mods();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parsetrigger_do();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f214(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_conditions",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_conditions",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_apply_mods() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_apply_mods",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 302;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_apply_mods",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_apply_mods",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseBEFORE();
    if (s1 === peg$FAILED) {
      s1 = peg$parseAFTER();
      if (s1 === peg$FAILED) {
        s1 = peg$parsetrigger_apply_instead();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f215(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_apply_mods",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_apply_mods",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_apply_instead() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_apply_instead",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 303;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_apply_instead",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_apply_instead",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseINSTEAD();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseOF();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f216(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_apply_instead",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_apply_instead",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_do() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_do",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 304;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_do",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_do",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsetrigger_do_on();
    if (s0 === peg$FAILED) {
      s0 = peg$parsetrigger_do_update();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_do",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_do",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_do_on() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_do_on",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 305;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_do_on",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_do_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDELETE();
    if (s1 === peg$FAILED) {
      s1 = peg$parseINSERT();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f217(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_do_on",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_do_on",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_do_update() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_do_update",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 306;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_do_update",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_do_update",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseUPDATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsedo_update_of();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f218(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_do_update",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_do_update",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedo_update_of() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "do_update_of",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 307;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "do_update_of",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "do_update_of",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseOF();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsedo_update_columns();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f219(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "do_update_of",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "do_update_of",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedo_update_columns() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "do_update_columns",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 308;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "do_update_columns",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "do_update_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseloop_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = [];
      s4 = peg$parseloop_column_tail();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseloop_column_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f148(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "do_update_columns",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "do_update_columns",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_foreach() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_foreach",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 309;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_foreach",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_foreach",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseFOR();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseEACH();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseROW();
        if (s5 === peg$FAILED) {
          if (input.substr(peg$currPos, 9).toLowerCase() === peg$c7) {
            s5 = input.substr(peg$currPos, 9);
            peg$currPos += 9;
          } else {
            s5 = peg$FAILED;
          }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f220(s1, s3, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_foreach",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_foreach",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_when() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_when",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 310;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_when",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_when",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseWHEN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f221(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_when",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_when",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_action() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "trigger_action",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 311;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_action",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseBEGIN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseaction_loop();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseEND();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f222(s1, s3, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "trigger_action",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaction_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "action_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 312;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseaction_loop_stmt();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseaction_loop_stmt();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f223(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaction_loop_stmt() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "action_loop_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 313;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_loop_stmt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_loop_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsestmt_crud();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsesemi_required();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f2(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "action_loop_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "action_loop_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_view() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_view",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 314;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_view",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_view",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_view_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseid_view_expression();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parsecreate_as_select();
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f224(s1, s2, s3, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_view",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_view",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_view_expression() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_view_expression",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 315;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_view_expression",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_view_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_view();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseloop_columns();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f225(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseid_view();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_view_expression",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_view_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_view_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_view_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 316;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_view_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_view_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_tmp();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseVIEW();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f226(s1, s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_view_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_view_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_as_select() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_as_select",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 317;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_as_select",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_as_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseAS();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsestmt_select();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f147(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_as_select",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_as_select",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_virtual() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_virtual",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 318;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_virtual",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_virtual",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_virtual_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parseid_table();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseUSING();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parsevirtual_module();
          if (s7 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f227(s1, s2, s3, s7);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_virtual",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_virtual",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_virtual_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "create_virtual_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 319;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_virtual_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_virtual_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseVIRTUAL();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        s4 = peg$parseTABLE();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseo();
          peg$savedPos = s0;
          s0 = peg$f228(s1, s2, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "create_virtual_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_virtual_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevirtual_module() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "virtual_module",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 320;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_module",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_module",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsename_unquoted();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsevirtual_args();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f229(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_module",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_module",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevirtual_args() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "virtual_args",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 321;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_args",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsevirtual_args_loop();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parseo();
      s5 = peg$parsesym_pclose();
      if (s5 !== peg$FAILED) {
        s6 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f230(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_args",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevirtual_args_loop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "virtual_args_loop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 322;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_args_loop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_args_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsevirtual_arg_types();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsevirtual_args_tail();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsevirtual_args_tail();
      }
      peg$savedPos = s0;
      s0 = peg$f231(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_args_loop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_args_loop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevirtual_args_tail() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "virtual_args_tail",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 323;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_args_tail",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_args_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseo();
    s2 = peg$parsesym_comma();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s4 = peg$parsevirtual_arg_types();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f232(s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_args_tail",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_args_tail",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevirtual_arg_types() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "virtual_arg_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 324;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_arg_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_arg_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$currPos;
    s3 = peg$parsename();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseo();
      s5 = peg$parsetype_definition();
      if (s5 === peg$FAILED) {
        s5 = peg$parsecolumn_constraint();
      }
      if (s5 !== peg$FAILED) {
        s3 = [s3, s4, s5];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f149(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsevirtual_column_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$begin();
        s4 = peg$parsename_char();
        peg$end(true);
        if (s4 === peg$FAILED) {
          s3 = undefined;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseo();
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecolumn_type();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$parsecolumn_constraints();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f167(s1, s3, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_arg_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_arg_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevirtual_column_name() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "virtual_column_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 325;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_column_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_column_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsename();
    if (s0 === peg$FAILED) {
      s0 = peg$parsename_reserved();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "virtual_column_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "virtual_column_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_drop() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_drop",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 326;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_drop",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_drop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedrop_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseid_table();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f233(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_drop",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_drop",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedrop_start() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "drop_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 327;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "drop_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseDROP();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parsedrop_types();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsedrop_ie();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f234(s1, s3, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "drop_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedrop_types() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "drop_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 328;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "drop_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseTABLE();
    if (s1 === peg$FAILED) {
      s1 = peg$parseINDEX();
      if (s1 === peg$FAILED) {
        s1 = peg$parseTRIGGER();
        if (s1 === peg$FAILED) {
          s1 = peg$parseVIEW();
          if (s1 === peg$FAILED) {
            s1 = peg$parseDATABASE();
            if (s1 === peg$FAILED) {
              s1 = peg$parseSCHEMA();
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f129(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "drop_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedrop_ie() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "drop_ie",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 329;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "drop_ie",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_ie",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseIF();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseEXISTS();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        peg$savedPos = s0;
        s0 = peg$f235(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "drop_ie",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_ie",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_show() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_show",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 330;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_show",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_show",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseSHOW();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseid_name();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f236(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_show",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_show",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestmt_set() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "stmt_set",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 331;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_set",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_set",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseSET();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseid_name();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseo();
        s5 = peg$parseTO();
        if (s5 === peg$FAILED) {
          s5 = peg$parsesym_equal();
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parseo();
          s7 = peg$parseid_name();
          if (s7 === peg$FAILED) {
            s7 = peg$parseliteral_value();
          }
          if (s7 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f237(s3, s7);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "stmt_set",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "stmt_set",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_concat() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_concat",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 332;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_concat",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_concat",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_pipe();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_pipe();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_concat",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_concat",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_plus() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_plus",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 333;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_plus",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_plus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_plus();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_plus",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_plus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_minus() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_minus",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 334;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_minus",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_minus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_minus();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_minus",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_minus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_multiply() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_multiply",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 335;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_multiply",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_multiply",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_star();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_multiply",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_multiply",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_divide() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_divide",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 336;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_divide",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_divide",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_fslash();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_divide",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_divide",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_mod() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_mod",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 337;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_mod",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_mod",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_mod();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_mod",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_mod",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_left() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_left",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 338;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_left",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_left",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_lt();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_lt();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_left",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_left",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_right() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_right",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 339;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_right",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_gt();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_gt();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_and() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_and",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 340;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_and",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_and",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_amp();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_and",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_and",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_or() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_or",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 341;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_or",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_or",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_pipe();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_or",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_or",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_lt() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_lt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 342;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_lt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_lt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_lt();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_lt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_lt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_gt() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_gt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 343;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_gt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_gt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsesym_gt();

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_gt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_gt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_lte() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_lte",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 344;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_lte",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_lte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_lt();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_lte",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_lte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_gte() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_gte",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 345;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_gte",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_gte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_gt();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_gte",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_gte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_equal() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_equal",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 346;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_equal",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_equal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_equal();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s1 = [s1, s2];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_equal",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_equal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_notequal_a() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_notequal_a",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 347;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_notequal_a",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_notequal_a",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_excl();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_notequal_a",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_notequal_a",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_notequal_b() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_notequal_b",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 348;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_notequal_b",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_notequal_b",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_lt();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_gt();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_notequal_b",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_notequal_b",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebinary_lang_isnt() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "binary_lang_isnt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 349;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_lang_isnt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_lang_isnt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseIS();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseexpression_is_not();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f238(s1, s3);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "binary_lang_isnt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "binary_lang_isnt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_name() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 350;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsename();
    if (s0 === peg$FAILED) {
      s0 = peg$parsename_reserved();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_database() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_database",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 351;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_database",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_database",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f239(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_database",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_database",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_schema() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_schema",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 352;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_schema",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_schema",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f240(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_schema",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_schema",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_function() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_function",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 353;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_function",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_function",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseid_name();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f241(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_function",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_function",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_table() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_table",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 354;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_table",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseid_name();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f242(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_table",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_table_qualified() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_table_qualified",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 355;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_table_qualified",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_table_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_dot();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f243(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_table_qualified",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_table_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_column() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_column",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 356;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_column",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecolumn_qualifiers();
    if (s1 === peg$FAILED) {
      s1 = peg$parseid_column_qualified();
      if (s1 === peg$FAILED) {
        s1 = peg$parsecolumn_unqualified();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f244(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_column",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_unqualified() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_unqualified",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 357;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_unqualified",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_unqualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseo();
    peg$savedPos = s0;
    s1 = peg$f245();
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_unqualified",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_unqualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_qualifiers() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "column_qualifiers",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 358;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_qualifiers",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_qualifiers",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseid_column_qualified();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f246(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "column_qualifiers",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_qualifiers",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_column_qualified() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_column_qualified",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 359;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_column_qualified",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_column_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsesym_dot();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f18(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_column_qualified",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_column_qualified",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_collation() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_collation",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 360;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_collation",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_collation",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f247(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_collation",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_collation",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_savepoint() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_savepoint",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 361;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_savepoint",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_savepoint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f248(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_savepoint",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_savepoint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_index() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_index",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 362;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_index",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_index",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseid_name();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f249(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_index",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_index",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_trigger() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_trigger",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 363;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_trigger",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_trigger",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseid_name();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f250(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_trigger",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_trigger",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_view() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_view",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 364;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_view",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_view",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseid_name();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f251(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_view",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_view",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_pragma() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_pragma",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 365;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_pragma",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_pragma",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseid_name();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f252(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_pragma",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_pragma",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_cte() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_cte",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 366;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_cte",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_cte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table_expression();
    if (s1 === peg$FAILED) {
      s1 = peg$parseid_table();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f253(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_cte",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_cte",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_table_expression() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_table_expression",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 367;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_table_expression",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_table_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$parseloop_columns();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f254(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_table_expression",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_table_expression",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_constraint_table() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_constraint_table",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 368;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_constraint_table",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_constraint_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f255(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_constraint_table",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_constraint_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseid_constraint_column() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "id_constraint_column",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 369;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_constraint_column",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_constraint_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f256(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "id_constraint_column",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "id_constraint_column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_types() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_types",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 370;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_types",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedatatype_text();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f257(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsedatatype_real();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$begin();
        s3 = peg$parsename_char();
        peg$end(true);
        if (s3 === peg$FAILED) {
          s2 = undefined;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f258(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedatatype_numeric();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$begin();
          s3 = peg$parsename_char();
          peg$end(true);
          if (s3 === peg$FAILED) {
            s2 = undefined;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f259(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedatatype_integer();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$begin();
            s3 = peg$parsename_char();
            peg$end(true);
            if (s3 === peg$FAILED) {
              s2 = undefined;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f260(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedatatype_none();
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$begin();
              s3 = peg$parsename_char();
              peg$end(true);
              if (s3 === peg$FAILED) {
                s2 = undefined;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f261(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_types",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_types",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_text() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_text",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 371;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_text",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_text",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c8) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      s2 = null;
    }
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c9) {
      s3 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s3 = peg$FAILED;
    }
    if (s3 === peg$FAILED) {
      s3 = null;
    }
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c10) {
      s4 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s4 = peg$FAILED;
    }
    if (s4 !== peg$FAILED) {
      s2 = [s2, s3, s4];
      s1 = s2;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c11) {
        s2 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c12) {
          s2 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c13) {
            s2 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
          }
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c14) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c15) {
          s1 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f129(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_text",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_text",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_real() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_real",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 372;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_real",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_real",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedatatype_real_double();
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c16) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c17) {
          s1 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f129(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_real",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_real",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_real_double() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_real_double",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 373;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_real_double",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_real_double",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c18) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$r0.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c19) {
          s4 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f262(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_real_double",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_real_double",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_numeric() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_numeric",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 374;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_numeric",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_numeric",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c20) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c21) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c22) {
          s1 = input.substr(peg$currPos, 7);
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c23) {
            s2 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c24) {
              s3 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c24) {
              s2 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c25) {
                s3 = input.substr(peg$currPos, 5);
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c26) {
                s1 = input.substr(peg$currPos, 6);
                peg$currPos += 6;
              } else {
                s1 = peg$FAILED;
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f129(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_numeric",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_numeric",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_integer() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_integer",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 375;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_integer",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_integer",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c27) {
      s2 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 50) {
        s3 = peg$c28;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 52) {
          s3 = peg$c29;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 56) {
            s3 = peg$c30;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c31) {
              s3 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;
            }
          }
        }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c32) {
        s2 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c12) {
          s2 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c33) {
            s2 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c11) {
              s2 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s2 = peg$FAILED;
            }
          }
        }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c27) {
        s3 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parsedatatype_integer_fp();
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f129(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_integer",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_integer",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_integer_fp() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_integer_fp",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 376;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_integer_fp",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_integer_fp",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c34) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$r0.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c35) {
          s4 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f263(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_integer_fp",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_integer_fp",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatatype_none() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "datatype_none",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 377;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_none",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_none",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c36) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f129(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "datatype_none",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datatype_none",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_char() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_char",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 378;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_char",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    if (peg$r8.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_char",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseunicode_char() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "unicode_char",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 379;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "unicode_char",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "unicode_char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c37) {
      s1 = peg$c37;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$r9.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$r9.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f264(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "unicode_char",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "unicode_char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 380;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsename_quoted();
    if (s0 === peg$FAILED) {
      s0 = peg$parsename_unquoted();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_quoted() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_quoted",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 381;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_quoted",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_quoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsename_bracketed();
    if (s0 === peg$FAILED) {
      s0 = peg$parsename_backticked();
      if (s0 === peg$FAILED) {
        s0 = peg$parsename_dblquoted();
        if (s0 === peg$FAILED) {
          s0 = peg$parsename_sglquoted();
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_quoted",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_quoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_unquoted() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_unquoted",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 382;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_unquoted",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_unquoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$parsereserved_words();
    if (s2 === peg$FAILED) {
      s2 = peg$parsenumber_digit();
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseunicode_char();
      if (s3 === peg$FAILED) {
        s3 = peg$parsename_char();
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseunicode_char();
          if (s3 === peg$FAILED) {
            s3 = peg$parsename_char();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f96(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_unquoted",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_unquoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_reserved() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_reserved",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 383;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_reserved",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_reserved",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$parsereserved_critical_list();
    if (s2 === peg$FAILED) {
      s2 = peg$parsenumber_digit();
    }
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseunicode_char();
      if (s3 === peg$FAILED) {
        s3 = peg$parsename_char();
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseunicode_char();
          if (s3 === peg$FAILED) {
            s3 = peg$parsename_char();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f265(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_reserved",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_reserved",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_bracketed() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_bracketed",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 384;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_bracketed",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_bracketed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsesym_bopen();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      s3 = peg$currPos;
      s4 = [];
      s5 = peg$currPos;
      s6 = peg$currPos;
      peg$begin();
      s7 = peg$parsebracket_terminator();
      peg$end(true);
      if (s7 === peg$FAILED) {
        s6 = undefined;
      } else {
        peg$currPos = s6;
        s6 = peg$FAILED;
      }
      if (s6 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s7 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s7 = peg$FAILED;
        }
        if (s7 !== peg$FAILED) {
          s6 = [s6, s7];
          s5 = s6;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
      } else {
        peg$currPos = s5;
        s5 = peg$FAILED;
      }
      while (s5 !== peg$FAILED) {
        s4.push(s5);
        s5 = peg$currPos;
        s6 = peg$currPos;
        peg$begin();
        s7 = peg$parsebracket_terminator();
        peg$end(true);
        if (s7 === peg$FAILED) {
          s6 = undefined;
        } else {
          peg$currPos = s6;
          s6 = peg$FAILED;
        }
        if (s6 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
      }
      s3 = input.substring(s3, peg$currPos);
      s4 = peg$parsebracket_terminator();
      if (s4 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f266(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_bracketed",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_bracketed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebracket_terminator() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "bracket_terminator",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 385;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bracket_terminator",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bracket_terminator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    if (peg$r10.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (peg$r10.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
      }
    }
    s2 = peg$parsesym_bclose();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseo();
      s1 = [s1, s2, s3];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "bracket_terminator",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "bracket_terminator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_dblquoted() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_dblquoted",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 386;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_dblquoted",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_dblquoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c38;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (input.substr(peg$currPos, 2) === peg$c39) {
        s3 = peg$c39;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        if (peg$r11.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 2) === peg$c39) {
          s3 = peg$c39;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          if (peg$r11.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
        }
      }
      if (input.charCodeAt(peg$currPos) === 34) {
        s3 = peg$c38;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f267(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_dblquoted",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_dblquoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_sglquoted() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_sglquoted",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 387;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_sglquoted",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_sglquoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c40;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (input.substr(peg$currPos, 2) === peg$c0) {
        s3 = peg$c0;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 2) === peg$c0) {
          s3 = peg$c0;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
        }
      }
      if (input.charCodeAt(peg$currPos) === 39) {
        s3 = peg$c40;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f268(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_sglquoted",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_sglquoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsename_backticked() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "name_backticked",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 388;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_backticked",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_backticked",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 96) {
      s1 = peg$c41;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (input.substr(peg$currPos, 2) === peg$c42) {
        s3 = peg$c42;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        if (peg$r12.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 2) === peg$c42) {
          s3 = peg$c42;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          if (peg$r12.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
        }
      }
      if (input.charCodeAt(peg$currPos) === 96) {
        s3 = peg$c41;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f269(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "name_backticked",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "name_backticked",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_bopen() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_bopen",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 389;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_bopen",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_bopen",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c43;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_bopen",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_bopen",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_bclose() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_bclose",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 390;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_bclose",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_bclose",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 93) {
      s1 = peg$c44;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_bclose",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_bclose",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_popen() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_popen",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 391;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_popen",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_popen",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c45;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_popen",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_popen",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_pclose() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_pclose",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 392;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_pclose",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_pclose",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 41) {
      s1 = peg$c46;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_pclose",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_pclose",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_comma() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_comma",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 393;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_comma",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_comma",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 44) {
      s1 = peg$c47;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_comma",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_comma",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_dot() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_dot",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 394;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_dot",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_dot",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s1 = peg$c48;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_dot",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_dot",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_star() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_star",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 395;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_star",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_star",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 42) {
      s1 = peg$c49;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_star",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_star",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_quest() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_quest",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 396;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_quest",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_quest",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 63) {
      s1 = peg$c50;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_quest",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_quest",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_sglquote() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_sglquote",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 397;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_sglquote",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_sglquote",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c40;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_sglquote",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_sglquote",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_dblquote() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_dblquote",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 398;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_dblquote",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_dblquote",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c38;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_dblquote",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_dblquote",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_backtick() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_backtick",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 399;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_backtick",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_backtick",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 96) {
      s1 = peg$c41;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_backtick",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_backtick",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_tilde() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_tilde",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 400;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_tilde",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_tilde",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 126) {
      s1 = peg$c51;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_tilde",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_tilde",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_plus() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_plus",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 401;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_plus",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_plus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 43) {
      s1 = peg$c52;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_plus",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_plus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_minus() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_minus",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 402;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_minus",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_minus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c53;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_minus",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_minus",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_equal() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_equal",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 403;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_equal",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_equal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      s1 = peg$c54;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_equal",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_equal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_amp() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_amp",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 404;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_amp",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_amp",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      s1 = peg$c55;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_amp",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_amp",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_pipe() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_pipe",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 405;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_pipe",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_pipe",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 124) {
      s1 = peg$c56;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_pipe",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_pipe",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_mod() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_mod",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 406;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_mod",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_mod",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 37) {
      s1 = peg$c57;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_mod",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_mod",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_lt() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_lt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 407;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_lt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_lt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      s1 = peg$c58;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_lt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_lt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_gt() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_gt",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 408;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_gt",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_gt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 62) {
      s1 = peg$c59;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_gt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_gt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_excl() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_excl",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 409;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_excl",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_excl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 33) {
      s1 = peg$c60;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_excl",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_excl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_semi() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_semi",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 410;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_semi",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_semi",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    rule$expects(peg$e1);
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      s1 = peg$c61;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_semi",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_semi",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_colon() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_colon",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 411;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_colon",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_colon",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      s1 = peg$c4;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_colon",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_colon",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_fslash() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_fslash",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 412;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_fslash",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_fslash",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      s1 = peg$c62;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_fslash",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_fslash",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesym_bslash() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "sym_bslash",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 413;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_bslash",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_bslash",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s1 = peg$c63;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseo();
      peg$savedPos = s0;
      s0 = peg$f2(s1);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "sym_bslash",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sym_bslash",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseABORT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ABORT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 414;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ABORT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ABORT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c64) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ABORT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ABORT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseACTION() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ACTION",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 415;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ACTION",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ACTION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c65) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ACTION",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ACTION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseADD() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ADD",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 416;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ADD",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ADD",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c66) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ADD",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ADD",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseAFTER() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "AFTER",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 417;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AFTER",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AFTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c67) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AFTER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AFTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ALL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 418;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ALL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c68) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ALL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ALTER",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 419;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ALTER",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c69) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ALTER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseANALYZE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ANALYZE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 420;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ANALYZE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ANALYZE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c70) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ANALYZE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ANALYZE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseAND() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "AND",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 421;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AND",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AND",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c71) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AND",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AND",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseAS() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "AS",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 422;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AS",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c72) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseASC() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ASC",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 423;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ASC",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ASC",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c73) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ASC",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ASC",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseATTACH() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ATTACH",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 424;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ATTACH",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ATTACH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c74) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ATTACH",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ATTACH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseAUTOINCREMENT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "AUTOINCREMENT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 425;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AUTOINCREMENT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AUTOINCREMENT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 13).toLowerCase() === peg$c75) {
      s1 = input.substr(peg$currPos, 13);
      peg$currPos += 13;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "AUTOINCREMENT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "AUTOINCREMENT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseBEFORE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "BEFORE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 426;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BEFORE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BEFORE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c76) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BEFORE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BEFORE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseBEGIN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "BEGIN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 427;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BEGIN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BEGIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c77) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BEGIN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BEGIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseBETWEEN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "BETWEEN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 428;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BETWEEN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BETWEEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c78) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BETWEEN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BETWEEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseBY() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "BY",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 429;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BY",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c79) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "BY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "BY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCASCADE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CASCADE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 430;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CASCADE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CASCADE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c80) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CASCADE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CASCADE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCASE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CASE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 431;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CASE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c81) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CASE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCAST() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CAST",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 432;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CAST",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CAST",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c82) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CAST",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CAST",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCHECK() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CHECK",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 433;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CHECK",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CHECK",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c83) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CHECK",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CHECK",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCOLLATE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "COLLATE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 434;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "COLLATE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "COLLATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c84) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "COLLATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "COLLATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCOLUMN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "COLUMN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 435;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "COLUMN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "COLUMN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c85) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "COLUMN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "COLUMN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCOMMIT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "COMMIT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 436;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "COMMIT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "COMMIT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c86) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "COMMIT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "COMMIT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCONFLICT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CONFLICT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 437;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CONFLICT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CONFLICT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c87) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CONFLICT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CONFLICT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCONSTRAINT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CONSTRAINT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 438;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CONSTRAINT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CONSTRAINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c88) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CONSTRAINT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CONSTRAINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCREATE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CREATE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 439;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CREATE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CREATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c89) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CREATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CREATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCROSS() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CROSS",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 440;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CROSS",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CROSS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c90) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CROSS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CROSS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCURRENT_DATE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CURRENT_DATE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 441;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CURRENT_DATE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CURRENT_DATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c91) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CURRENT_DATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CURRENT_DATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCURRENT_TIME() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CURRENT_TIME",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 442;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CURRENT_TIME",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CURRENT_TIME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c92) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CURRENT_TIME",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CURRENT_TIME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCURRENT_TIMESTAMP() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "CURRENT_TIMESTAMP",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 443;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CURRENT_TIMESTAMP",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CURRENT_TIMESTAMP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 17).toLowerCase() === peg$c93) {
      s1 = input.substr(peg$currPos, 17);
      peg$currPos += 17;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "CURRENT_TIMESTAMP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "CURRENT_TIMESTAMP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDATABASE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DATABASE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 444;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DATABASE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DATABASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c94) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DATABASE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DATABASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDEFAULT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DEFAULT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 445;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DEFAULT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DEFAULT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c95) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DEFAULT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DEFAULT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDEFERRABLE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DEFERRABLE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 446;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DEFERRABLE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DEFERRABLE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c96) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DEFERRABLE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DEFERRABLE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDEFERRED() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DEFERRED",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 447;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DEFERRED",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DEFERRED",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c97) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DEFERRED",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DEFERRED",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDELETE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DELETE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 448;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DELETE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DELETE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c98) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DELETE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DELETE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDESC() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DESC",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 449;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DESC",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DESC",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c99) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DESC",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DESC",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDETACH() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DETACH",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 450;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DETACH",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DETACH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c100) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DETACH",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DETACH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDISTINCT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DISTINCT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 451;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DISTINCT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DISTINCT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c101) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DISTINCT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DISTINCT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDROP() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "DROP",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 452;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DROP",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DROP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c102) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "DROP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DROP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEACH() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "EACH",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 453;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EACH",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EACH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c103) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EACH",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EACH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseELSE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ELSE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 454;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ELSE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ELSE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c104) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ELSE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ELSE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEND() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "END",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 455;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "END",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "END",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c105) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "END",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "END",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseESCAPE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ESCAPE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 456;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ESCAPE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ESCAPE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c106) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ESCAPE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ESCAPE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEXCEPT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "EXCEPT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 457;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXCEPT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXCEPT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c107) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXCEPT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXCEPT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEXCLUSIVE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "EXCLUSIVE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 458;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXCLUSIVE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXCLUSIVE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c108) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXCLUSIVE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXCLUSIVE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEXISTS() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "EXISTS",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 459;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXISTS",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXISTS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c109) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXISTS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXISTS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEXPLAIN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "EXPLAIN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 460;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXPLAIN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXPLAIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "EXPLAIN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EXPLAIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseFAIL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "FAIL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 461;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FAIL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FAIL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c111) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FAIL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FAIL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseFOR() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "FOR",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 462;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FOR",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FOR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c112) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FOR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FOR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseFOREIGN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "FOREIGN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 463;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FOREIGN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FOREIGN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c113) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FOREIGN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FOREIGN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseFROM() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "FROM",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 464;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FROM",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FROM",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c114) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FROM",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FROM",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseFULL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "FULL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 465;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FULL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "FULL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "FULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseGLOB() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "GLOB",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 466;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "GLOB",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "GLOB",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c116) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "GLOB",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "GLOB",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseGROUP() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "GROUP",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 467;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "GROUP",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "GROUP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c117) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "GROUP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "GROUP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseHAVING() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "HAVING",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 468;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "HAVING",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "HAVING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c118) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "HAVING",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "HAVING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseIF() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "IF",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 469;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IF",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IF",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c119) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IF",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IF",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseIGNORE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "IGNORE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 470;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IGNORE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IGNORE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c120) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IGNORE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IGNORE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseIMMEDIATE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "IMMEDIATE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 471;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IMMEDIATE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IMMEDIATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c121) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IMMEDIATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IMMEDIATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseIN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "IN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 472;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c122) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINDEX() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INDEX",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 473;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INDEX",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INDEX",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c123) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INDEX",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INDEX",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINDEXED() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INDEXED",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 474;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INDEXED",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INDEXED",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c124) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INDEXED",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INDEXED",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINITIALLY() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INITIALLY",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 475;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INITIALLY",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INITIALLY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c125) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INITIALLY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INITIALLY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINNER() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INNER",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 476;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INNER",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INNER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c126) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INNER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INNER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINSERT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INSERT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 477;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INSERT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INSERT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c127) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INSERT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INSERT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINSTEAD() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INSTEAD",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 478;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INSTEAD",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INSTEAD",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c128) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INSTEAD",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INSTEAD",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINTERSECT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INTERSECT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 479;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INTERSECT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INTERSECT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c129) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INTERSECT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INTERSECT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseINTO() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "INTO",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 480;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INTO",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INTO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c130) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "INTO",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "INTO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseIS() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "IS",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 481;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IS",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c131) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "IS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "IS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseISNULL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ISNULL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 482;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ISNULL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ISNULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c132) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ISNULL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ISNULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseJOIN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "JOIN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 483;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "JOIN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "JOIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c133) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "JOIN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "JOIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKEY() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "KEY",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 484;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "KEY",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KEY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c134) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "KEY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KEY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseLEFT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "LEFT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 485;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "LEFT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LEFT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c135) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "LEFT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LEFT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseLIKE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "LIKE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 486;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "LIKE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LIKE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c136) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "LIKE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LIKE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseLIMIT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "LIMIT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 487;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "LIMIT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LIMIT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c137) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "LIMIT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LIMIT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseMATCH() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "MATCH",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 488;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "MATCH",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "MATCH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c138) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "MATCH",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "MATCH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseNATURAL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "NATURAL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 489;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NATURAL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NATURAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c139) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NATURAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NATURAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseNO() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "NO",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 490;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NO",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c140) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NO",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseNOT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "NOT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 491;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NOT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NOT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c141) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NOT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NOT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseNOTNULL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "NOTNULL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 492;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NOTNULL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NOTNULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c142) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NOTNULL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NOTNULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseNULL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "NULL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 493;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NULL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c6) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "NULL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "NULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOF() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "OF",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 494;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OF",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OF",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c143) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OF",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OF",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOFFSET() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "OFFSET",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 495;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OFFSET",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OFFSET",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c144) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OFFSET",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OFFSET",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseON() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ON",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 496;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ON",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ON",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c145) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ON",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ON",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOR() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "OR",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 497;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OR",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c146) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseORDER() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ORDER",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 498;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ORDER",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ORDER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c147) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ORDER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ORDER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOUTER() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "OUTER",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 499;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OUTER",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OUTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c148) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "OUTER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OUTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsePLAN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "PLAN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 500;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "PLAN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "PLAN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c149) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "PLAN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "PLAN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsePRAGMA() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "PRAGMA",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 501;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "PRAGMA",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "PRAGMA",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c150) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "PRAGMA",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "PRAGMA",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsePRIMARY() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "PRIMARY",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 502;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "PRIMARY",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "PRIMARY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c151) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "PRIMARY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "PRIMARY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseQUERY() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "QUERY",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 503;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "QUERY",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "QUERY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c152) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "QUERY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "QUERY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRAISE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "RAISE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 504;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RAISE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RAISE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c153) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RAISE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RAISE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRECURSIVE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "RECURSIVE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 505;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RECURSIVE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RECURSIVE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c154) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RECURSIVE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RECURSIVE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseREFERENCES() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "REFERENCES",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 506;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REFERENCES",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REFERENCES",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c155) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REFERENCES",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REFERENCES",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseREGEXP() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "REGEXP",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 507;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REGEXP",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REGEXP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c156) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REGEXP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REGEXP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseREINDEX() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "REINDEX",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 508;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REINDEX",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REINDEX",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c157) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REINDEX",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REINDEX",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRELEASE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "RELEASE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 509;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RELEASE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RELEASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c158) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RELEASE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RELEASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRENAME() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "RENAME",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 510;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RENAME",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RENAME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c159) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RENAME",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RENAME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseREPLACE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "REPLACE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 511;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REPLACE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REPLACE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c160) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "REPLACE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "REPLACE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRESTRICT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "RESTRICT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 512;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RESTRICT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RESTRICT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c161) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RESTRICT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RESTRICT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRIGHT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "RIGHT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 513;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RIGHT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RIGHT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c162) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "RIGHT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RIGHT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseROLLBACK() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ROLLBACK",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 514;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ROLLBACK",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ROLLBACK",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c163) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ROLLBACK",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ROLLBACK",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseROW() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ROW",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 515;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ROW",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ROW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c164) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ROW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ROW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseROWID() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "ROWID",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 516;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ROWID",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ROWID",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c165) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "ROWID",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ROWID",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSAVEPOINT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "SAVEPOINT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 517;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SAVEPOINT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SAVEPOINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c166) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SAVEPOINT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SAVEPOINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSCHEMA() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "SCHEMA",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 518;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SCHEMA",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SCHEMA",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c167) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SCHEMA",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SCHEMA",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSELECT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "SELECT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 519;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SELECT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SELECT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c168) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SELECT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SELECT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSET() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "SET",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 520;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SET",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SET",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c169) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SET",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SET",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSHOW() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "SHOW",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 521;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SHOW",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SHOW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c170) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "SHOW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SHOW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseTABLE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "TABLE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 522;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TABLE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TABLE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c171) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TABLE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TABLE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseTEMP() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "TEMP",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 523;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TEMP",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TEMP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c172) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TEMP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TEMP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseTEMPORARY() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "TEMPORARY",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 524;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TEMPORARY",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TEMPORARY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c173) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TEMPORARY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TEMPORARY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseTHEN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "THEN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 525;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "THEN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "THEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c174) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "THEN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "THEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseTO() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "TO",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 526;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TO",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c175) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TO",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseTRANSACTION() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "TRANSACTION",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 527;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TRANSACTION",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TRANSACTION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 11).toLowerCase() === peg$c176) {
      s1 = input.substr(peg$currPos, 11);
      peg$currPos += 11;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TRANSACTION",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TRANSACTION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseTRIGGER() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "TRIGGER",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 528;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TRIGGER",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TRIGGER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c177) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "TRIGGER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "TRIGGER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseUNION() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "UNION",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 529;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "UNION",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "UNION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c178) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "UNION",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "UNION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseUNIQUE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "UNIQUE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 530;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "UNIQUE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "UNIQUE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c179) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "UNIQUE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "UNIQUE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseUPDATE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "UPDATE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 531;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "UPDATE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "UPDATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c180) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "UPDATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "UPDATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseUSING() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "USING",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 532;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "USING",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "USING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c181) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "USING",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "USING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseVACUUM() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "VACUUM",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 533;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VACUUM",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VACUUM",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c182) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VACUUM",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VACUUM",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseVALUES() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "VALUES",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 534;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VALUES",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VALUES",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c183) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VALUES",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VALUES",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseVIEW() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "VIEW",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 535;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VIEW",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VIEW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c184) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VIEW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VIEW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseVIRTUAL() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "VIRTUAL",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 536;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VIRTUAL",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VIRTUAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c185) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "VIRTUAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "VIRTUAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseWHEN() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "WHEN",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 537;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WHEN",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WHEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c186) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WHEN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WHEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseWHERE() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "WHERE",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 538;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WHERE",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WHERE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c187) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WHERE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WHERE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseWITH() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "WITH",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 539;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WITH",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WITH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c188) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WITH",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WITH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseWITHOUT() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "WITHOUT",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 540;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WITHOUT",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WITHOUT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c189) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$begin();
      s3 = peg$parsename_char();
      peg$end(true);
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "WITHOUT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WITHOUT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereserved_words() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "reserved_words",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 541;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reserved_words",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reserved_words",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsereserved_word_list();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f270(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reserved_words",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reserved_words",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereserved_word_list() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "reserved_word_list",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 542;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reserved_word_list",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reserved_word_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseABORT();
    if (s0 === peg$FAILED) {
      s0 = peg$parseACTION();
      if (s0 === peg$FAILED) {
        s0 = peg$parseADD();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAFTER();
          if (s0 === peg$FAILED) {
            s0 = peg$parseALL();
            if (s0 === peg$FAILED) {
              s0 = peg$parseALTER();
              if (s0 === peg$FAILED) {
                s0 = peg$parseANALYZE();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseAND();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseAS();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseASC();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseATTACH();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseAUTOINCREMENT();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseBEFORE();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseBEGIN();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseBETWEEN();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseBY();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseCASCADE();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parseCASE();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseCAST();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parseCHECK();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$parseCOLLATE();
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$parseCOLUMN();
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$parseCOMMIT();
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$parseCONFLICT();
                                                  if (s0 === peg$FAILED) {
                                                    s0 = peg$parseCONSTRAINT();
                                                    if (s0 === peg$FAILED) {
                                                      s0 = peg$parseCREATE();
                                                      if (s0 === peg$FAILED) {
                                                        s0 = peg$parseCROSS();
                                                        if (s0 === peg$FAILED) {
                                                          s0 = peg$parseCURRENT_DATE();
                                                          if (s0 === peg$FAILED) {
                                                            s0 = peg$parseCURRENT_TIME();
                                                            if (s0 === peg$FAILED) {
                                                              s0 = peg$parseCURRENT_TIMESTAMP();
                                                              if (s0 === peg$FAILED) {
                                                                s0 = peg$parseDATABASE();
                                                                if (s0 === peg$FAILED) {
                                                                  s0 = peg$parseDEFAULT();
                                                                  if (s0 === peg$FAILED) {
                                                                    s0 = peg$parseDEFERRABLE();
                                                                    if (s0 === peg$FAILED) {
                                                                      s0 = peg$parseDEFERRED();
                                                                      if (s0 === peg$FAILED) {
                                                                        s0 = peg$parseDELETE();
                                                                        if (s0 === peg$FAILED) {
                                                                          s0 = peg$parseDESC();
                                                                          if (s0 === peg$FAILED) {
                                                                            s0 = peg$parseDETACH();
                                                                            if (s0 === peg$FAILED) {
                                                                              s0 = peg$parseDISTINCT();
                                                                              if (s0 === peg$FAILED) {
                                                                                s0 = peg$parseDROP();
                                                                                if (s0 === peg$FAILED) {
                                                                                  s0 = peg$parseEACH();
                                                                                  if (s0 === peg$FAILED) {
                                                                                    s0 = peg$parseELSE();
                                                                                    if (s0 === peg$FAILED) {
                                                                                      s0 = peg$parseEND();
                                                                                      if (s0 === peg$FAILED) {
                                                                                        s0 = peg$parseESCAPE();
                                                                                        if (s0 === peg$FAILED) {
                                                                                          s0 = peg$parseEXCEPT();
                                                                                          if (s0 === peg$FAILED) {
                                                                                            s0 = peg$parseEXCLUSIVE();
                                                                                            if (s0 === peg$FAILED) {
                                                                                              s0 = peg$parseEXISTS();
                                                                                              if (s0 === peg$FAILED) {
                                                                                                s0 = peg$parseEXPLAIN();
                                                                                                if (s0 === peg$FAILED) {
                                                                                                  s0 = peg$parseFAIL();
                                                                                                  if (s0 === peg$FAILED) {
                                                                                                    s0 = peg$parseFOR();
                                                                                                    if (s0 === peg$FAILED) {
                                                                                                      s0 = peg$parseFOREIGN();
                                                                                                      if (s0 === peg$FAILED) {
                                                                                                        s0 = peg$parseFROM();
                                                                                                        if (s0 === peg$FAILED) {
                                                                                                          s0 = peg$parseFULL();
                                                                                                          if (s0 === peg$FAILED) {
                                                                                                            s0 = peg$parseGLOB();
                                                                                                            if (s0 === peg$FAILED) {
                                                                                                              s0 = peg$parseGROUP();
                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                s0 = peg$parseHAVING();
                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                  s0 = peg$parseIF();
                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                    s0 = peg$parseIGNORE();
                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                      s0 = peg$parseIMMEDIATE();
                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                        s0 = peg$parseIN();
                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                          s0 = peg$parseINDEX();
                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                            s0 = peg$parseINDEXED();
                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                              s0 = peg$parseINITIALLY();
                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                s0 = peg$parseINNER();
                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                  s0 = peg$parseINSERT();
                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                    s0 = peg$parseINSTEAD();
                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                      s0 = peg$parseINTERSECT();
                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                        s0 = peg$parseINTO();
                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                          s0 = peg$parseIS();
                                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                                            s0 = peg$parseISNULL();
                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                              s0 = peg$parseJOIN();
                                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                                s0 = peg$parseKEY();
                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                  s0 = peg$parseLEFT();
                                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                                    s0 = peg$parseLIKE();
                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                      s0 = peg$parseLIMIT();
                                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                                        s0 = peg$parseMATCH();
                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                          s0 = peg$parseNATURAL();
                                                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                                                            s0 = peg$parseNO();
                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                              s0 = peg$parseNOT();
                                                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                                                s0 = peg$parseNOTNULL();
                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                  s0 = peg$parseNULL();
                                                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                                                    s0 = peg$parseOF();
                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                      s0 = peg$parseOFFSET();
                                                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                                                        s0 = peg$parseON();
                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                          s0 = peg$parseOR();
                                                                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                                                                            s0 = peg$parseORDER();
                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                              s0 = peg$parseOUTER();
                                                                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                                                                s0 = peg$parsePLAN();
                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                  s0 = peg$parsePRAGMA();
                                                                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                                                                    s0 = peg$parsePRIMARY();
                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                      s0 = peg$parseQUERY();
                                                                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                                                                        s0 = peg$parseRAISE();
                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                          s0 = peg$parseRECURSIVE();
                                                                                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                                                                                            s0 = peg$parseREFERENCES();
                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                              s0 = peg$parseREGEXP();
                                                                                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                                                                                s0 = peg$parseREINDEX();
                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                  s0 = peg$parseRELEASE();
                                                                                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                                                                                    s0 = peg$parseRENAME();
                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                      s0 = peg$parseREPLACE();
                                                                                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                                                                                        s0 = peg$parseRESTRICT();
                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                          s0 = peg$parseRIGHT();
                                                                                                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                                                                                                            s0 = peg$parseROLLBACK();
                                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                                              s0 = peg$parseROW();
                                                                                                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                                                                                                s0 = peg$parseSAVEPOINT();
                                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                                  s0 = peg$parseSELECT();
                                                                                                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                                                                                                    s0 = peg$parseSET();
                                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                                      s0 = peg$parseSHOW();
                                                                                                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                                                                                                        s0 = peg$parseTABLE();
                                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                                          s0 = peg$parseTEMPORARY();
                                                                                                                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                                                                                                                            s0 = peg$parseTHEN();
                                                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                                                              s0 = peg$parseTO();
                                                                                                                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                s0 = peg$parseTRANSACTION();
                                                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                  s0 = peg$parseTRIGGER();
                                                                                                                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                    s0 = peg$parseUNION();
                                                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                      s0 = peg$parseUNIQUE();
                                                                                                                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                        s0 = peg$parseUPDATE();
                                                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                          s0 = peg$parseUSING();
                                                                                                                                                                                                                                          if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                            s0 = peg$parseVACUUM();
                                                                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                              s0 = peg$parseVALUES();
                                                                                                                                                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                                s0 = peg$parseVIEW();
                                                                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                                  s0 = peg$parseVIRTUAL();
                                                                                                                                                                                                                                                  if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                                    s0 = peg$parseWHEN();
                                                                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                                      s0 = peg$parseWHERE();
                                                                                                                                                                                                                                                      if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                                        s0 = peg$parseWITH();
                                                                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                                                                          s0 = peg$parseWITHOUT();
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                      }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                  }
                                                                                                                                                                                                                }
                                                                                                                                                                                                              }
                                                                                                                                                                                                            }
                                                                                                                                                                                                          }
                                                                                                                                                                                                        }
                                                                                                                                                                                                      }
                                                                                                                                                                                                    }
                                                                                                                                                                                                  }
                                                                                                                                                                                                }
                                                                                                                                                                                              }
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                        }
                                                                                                                                                                                      }
                                                                                                                                                                                    }
                                                                                                                                                                                  }
                                                                                                                                                                                }
                                                                                                                                                                              }
                                                                                                                                                                            }
                                                                                                                                                                          }
                                                                                                                                                                        }
                                                                                                                                                                      }
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reserved_word_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reserved_word_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereserved_critical_list() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "reserved_critical_list",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 543;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reserved_critical_list",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reserved_critical_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parseADD();
    if (s0 === peg$FAILED) {
      s0 = peg$parseALL();
      if (s0 === peg$FAILED) {
        s0 = peg$parseALTER();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAND();
          if (s0 === peg$FAILED) {
            s0 = peg$parseAS();
            if (s0 === peg$FAILED) {
              s0 = peg$parseAUTOINCREMENT();
              if (s0 === peg$FAILED) {
                s0 = peg$parseBETWEEN();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseCASE();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseCHECK();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseCOLLATE();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseCOMMIT();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseCONSTRAINT();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseCREATE();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseDEFAULT();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseDEFERRABLE();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseDELETE();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseDISTINCT();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parseDROP();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseELSE();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parseESCAPE();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$parseEXCEPT();
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$parseEXISTS();
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$parseFOREIGN();
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$parseFROM();
                                                  if (s0 === peg$FAILED) {
                                                    s0 = peg$parseGROUP();
                                                    if (s0 === peg$FAILED) {
                                                      s0 = peg$parseHAVING();
                                                      if (s0 === peg$FAILED) {
                                                        s0 = peg$parseIN();
                                                        if (s0 === peg$FAILED) {
                                                          s0 = peg$parseINDEX();
                                                          if (s0 === peg$FAILED) {
                                                            s0 = peg$parseINSERT();
                                                            if (s0 === peg$FAILED) {
                                                              s0 = peg$parseINTERSECT();
                                                              if (s0 === peg$FAILED) {
                                                                s0 = peg$parseINTO();
                                                                if (s0 === peg$FAILED) {
                                                                  s0 = peg$parseIS();
                                                                  if (s0 === peg$FAILED) {
                                                                    s0 = peg$parseISNULL();
                                                                    if (s0 === peg$FAILED) {
                                                                      s0 = peg$parseJOIN();
                                                                      if (s0 === peg$FAILED) {
                                                                        s0 = peg$parseLIMIT();
                                                                        if (s0 === peg$FAILED) {
                                                                          s0 = peg$parseNOT();
                                                                          if (s0 === peg$FAILED) {
                                                                            s0 = peg$parseNOTNULL();
                                                                            if (s0 === peg$FAILED) {
                                                                              s0 = peg$parseNULL();
                                                                              if (s0 === peg$FAILED) {
                                                                                s0 = peg$parseON();
                                                                                if (s0 === peg$FAILED) {
                                                                                  s0 = peg$parseOR();
                                                                                  if (s0 === peg$FAILED) {
                                                                                    s0 = peg$parseORDER();
                                                                                    if (s0 === peg$FAILED) {
                                                                                      s0 = peg$parsePRIMARY();
                                                                                      if (s0 === peg$FAILED) {
                                                                                        s0 = peg$parseREFERENCES();
                                                                                        if (s0 === peg$FAILED) {
                                                                                          s0 = peg$parseSELECT();
                                                                                          if (s0 === peg$FAILED) {
                                                                                            s0 = peg$parseSET();
                                                                                            if (s0 === peg$FAILED) {
                                                                                              s0 = peg$parseTABLE();
                                                                                              if (s0 === peg$FAILED) {
                                                                                                s0 = peg$parseTHEN();
                                                                                                if (s0 === peg$FAILED) {
                                                                                                  s0 = peg$parseTO();
                                                                                                  if (s0 === peg$FAILED) {
                                                                                                    s0 = peg$parseTRANSACTION();
                                                                                                    if (s0 === peg$FAILED) {
                                                                                                      s0 = peg$parseUNION();
                                                                                                      if (s0 === peg$FAILED) {
                                                                                                        s0 = peg$parseUNIQUE();
                                                                                                        if (s0 === peg$FAILED) {
                                                                                                          s0 = peg$parseUPDATE();
                                                                                                          if (s0 === peg$FAILED) {
                                                                                                            s0 = peg$parseUSING();
                                                                                                            if (s0 === peg$FAILED) {
                                                                                                              s0 = peg$parseVALUES();
                                                                                                              if (s0 === peg$FAILED) {
                                                                                                                s0 = peg$parseWHEN();
                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                  s0 = peg$parseWHERE();
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "reserved_critical_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reserved_critical_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment() {
    var startPos = peg$currPos;
    var s0, s1;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "comment",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 544;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsecomment_line();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsecomment_block();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f271();
      }
      s0 = s1;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment_line() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3, s4, s5;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "comment_line",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 545;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_line",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_line",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c190) {
      s1 = peg$c190;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$begin();
      if (peg$r13.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
      }
      peg$end(true);
      if (s5 === peg$FAILED) {
        s4 = undefined;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$begin();
        if (peg$r13.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
        }
        peg$end(true);
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      s1 = [s1, s2];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_line",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_line",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment_block() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "comment_block",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 546;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsecomment_block_start();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsecomment_block_feed();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecomment_block_end();
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment_block_start() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "comment_block_start",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 547;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_start",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    if (input.substr(peg$currPos, 2) === peg$c191) {
      s0 = peg$c191;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment_block_end() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "comment_block_end",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 548;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_end",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_end",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    if (input.substr(peg$currPos, 2) === peg$c192) {
      s0 = peg$c192;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_end",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_end",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment_block_body() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "comment_block_body",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 549;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_body",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_body",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = [];
    s1 = peg$currPos;
    s2 = peg$currPos;
    peg$begin();
    s3 = peg$parsecomment_block_end();
    if (s3 === peg$FAILED) {
      s3 = peg$parsecomment_block_start();
    }
    peg$end(true);
    if (s3 === peg$FAILED) {
      s2 = undefined;
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$currPos;
        s2 = peg$currPos;
        peg$begin();
        s3 = peg$parsecomment_block_end();
        if (s3 === peg$FAILED) {
          s3 = peg$parsecomment_block_start();
        }
        peg$end(true);
        if (s3 === peg$FAILED) {
          s2 = undefined;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_body",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_body",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseblock_body_nodes() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "block_body_nodes",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 550;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "block_body_nodes",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "block_body_nodes",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$parsecomment_block_body();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecomment_block();
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "block_body_nodes",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "block_body_nodes",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment_block_feed() {
    var startPos = peg$currPos;
    var s0, s1, s2, s3;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "comment_block_feed",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 551;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_feed",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_feed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseblock_body_nodes();
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$r14.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = peg$parseblock_body_nodes();
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$r14.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = peg$parseblock_body_nodes();
        }
      }
      s1 = [s1, s2];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "comment_block_feed",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment_block_feed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseo() {
    var startPos = peg$currPos;
    var s0, s1, s2;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "o",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 552;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "o",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "o",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    rule$expects(peg$e2);
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$r14.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      s2 = peg$parsecomment();
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (peg$r14.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parsecomment();
      }
    }
    peg$savedPos = s0;
    s1 = peg$f8(s1);
    s0 = s1;
    peg$silentFails--;

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "o",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "o",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parse_TODO_() {
    var startPos = peg$currPos;
    var s0;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    peg$tracer.trace({
      type: "rule.enter",
      rule: "_TODO_",
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 554 + 553;
    var cached = peg$resultsCache[key];
    var rule$expectations = [];

    rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
      rule$expectations.push(expected);
    }

    if (cached) {
      peg$currPos = cached.nextPos;

      rule$expectations = cached.expectations;
      if (peg$silentFails === 0) {
        rule$expectations.forEach(peg$expect);
      }

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "_TODO_",
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "_TODO_",
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    if (input.substr(peg$currPos, 8) === peg$c193) {
      s0 = peg$c193;
      peg$currPos += 8;
    } else {
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0,
      expectations: rule$expectations
    };

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: "_TODO_",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "_TODO_",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }


    function makeArray(arr) {
      if (!isOkay(arr)) {
        return [];
      }
      return !Array.isArray(arr) ? [arr] : arr;
    }

    function isOkay(obj) {
      return obj != null;
    }

    function foldString(parts, glue = ' ') {
      const folded = parts
      .filter((part) => isOkay(part))
      .reduce((prev, cur) => {
        return `${prev}${nodeToString(cur)}${glue}`;
      }, '');
      return folded.trim();
    }

    function foldStringWord(parts) {
      return foldString(parts, '');
    }

    function foldStringKey(parts) {
      return foldString(parts).toLowerCase();
    }

    function flattenAll(arr) {
      return arr
      .filter((part) => isOkay(part))
      .reduce((prev, cur) => prev.concat(cur), []);
    }

    function unescape(str, quoteChar = '\'') {
      const re = new RegExp(`${quoteChar}{2}`, 'g');
      return nodeToString(str).replace(re, quoteChar);
    }

    function nodeToString(node = []) {
      return makeArray(node).join('');
    }

    /*
     * A text node has
     * - no leading or trailing whitespace
     */
    function textNode(node) {
      return nodeToString(node).trim();
    }

    function keyNode(node) {
      return textNode(node).toLowerCase();
    }

    function isArrayOkay(arr) {
      return Array.isArray(arr) && arr.length > 0 && isOkay(arr[0]);
    }

    function composeBinary(first, rest) {
      return rest
      .reduce((left, [ x, operation, y, right ]) => {
        return {
          'type': 'expression',
          'format': 'binary',
          'variant': 'operation',
          'operation': keyNode(operation),
          'left': left,
          'right': right
        };
      }, first);
    }


  peg$begin();
  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$expect(peg$endExpectation());
    }

    throw peg$buildError();
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  DefaultTracer: peg$DefaultTracer,
  parse: peg$parse
};
